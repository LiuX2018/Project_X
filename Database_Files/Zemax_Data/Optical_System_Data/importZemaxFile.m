function opticalSystemObject = importZemaxFile (zmxFullFileName,...
    coatingCatalogueListFullNames,glassCatalogueListFullNames)
% importZemaxFile: imports lens data from .zmx file format generated by zemax.
% when unsupported feature is found, display the command in the command window.
% Input:
% 	zmxFullFileName: Full file name of .zmx file including its path.
% Output:
%	opticalSystemObject: Optical system object


% <<<<<<<<<<<<<<<<<<<<<<< Algorithm Section>>>>>>>>>>>>>>>>>>>>>>>>>>>>


% <<<<<<<<<<<<<<<<<<<<<<<<< Example Usage>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
%

% <<<<<<<<<<<<<<<<<<<<<<<<< Author Section >>>>>>>>>>>>>>>>>>>>>>>>>>>>
%   Written By: Worku, Norman Girma
%   Advisor: Prof. Herbert Gross
%   Part of the RAYTRACE_TOOLBOX V3.0 (OOP Version)
%	Optical System Design and Simulation Research Group
%   Institute of Applied Physics
%   Friedrich-Schiller-University of Jena

% <<<<<<<<<<<<<<<<<<< Change History Section >>>>>>>>>>>>>>>>>>>>>>>>>>
% Date----------Modified By ---------Modification Detail--------Remark
% Oct 14,2013   Worku, Norman G.     Original Version       Version 3.0

% <<<<<<<<<<<<<<<<<<<<< Main Code Section >>>>>>>>>>>>>>>>>>>>>>>>>>>>>

% create an empty optical system object
mySystem = OpticalSystem;
surfCounter = 0;
nSurf = 0;
% convert unicode to ascii format running DOS command
command = ['TYPE "',zmxFullFileName,'">"temAnsiFile"'];
status = dos(command);
% read the input file
inputFile = fopen('temAnsiFile', 'r');

% locate the beginning of the file
currentPos = ftell(inputFile);

% read the next valid line
skipNextLineRead = 0;
currentLine = readNextLine(inputFile);
disp('Started: Importing system configuration data...');
while ( ~strcmpi(currentLine,'EOF') )
    % read the line as space separated string
    currentLineArray = strread(currentLine,'%s');
    
    % The first element of the array is the 4 character zmx command
    zmxCommand = char(currentLineArray(1,:));
    
    switch zmxCommand
        case 'VERS'
            % The version number of Zemax file used to create the .zmx file.
            zmxVersion = char(currentLineArray(2,:));
            year = str2num(zmxVersion(1:2));
            if year ~= 13
                choice = questdlg(['Your zemax file is version ',...
                    zmxVersion,...
                    '. It does not seem to be Zemax version 13 files (which',...
                    'are imported properly by the toolbox). Do you want to try any way?'], ...
                    'Incompatable ZMX File', ...
                    'Yes','No','Yes');
                % Handle response
                switch choice
                    case 'Yes'
                        
                    case 'No'
                        opticalSystemObject = OpticalSystem;
                        return;                        
                end
        
%                 msgbox(['Your zemax file is version ',...
%                     zmxVersion,...
%                     '. It does not seem to be Zemax version 13 files (which',...
%                     'are imported properly by the toolbox). Do you want to try any way?',...
%                     ' Covert your file and try again.'],'Old Zemax File');
%                 opticalSystemObject = OpticalSystem;
%                 return;
            end
        case 'ENPD'
            % ENPD val	: Entrance Pupil Diameter Value
            mySystem.SystemApertureType = 1;
            mySystem.SystemApertureValue = (str2num(char(currentLineArray(2,:))));
        case 'ENVD'
            % ENVD temp pres on	: Environment data. The temp and pres values are in
            % degrees c and atmospheres, respectively. On = 0 or 1: Indicate whether to adjust index to environment data (1) or not (0).
            disp('Environment data is not supported!!');
        case 'FLOA'
            % FLOA val	: Float by stop size. val is just ignored
            disp('Floating system aperture by stop size is not supported!! ');
            disp('Warning: Edit the system aperture system');
        case 'FNUM'
            % FNUM  val I	I = 0:Image Space F/# Value I = 1:Paraxial Working F/#
            disp('Image space F/# value  is not supported!! ');
            disp('Warning: Edit the system aperture system.');
        case 'SDMA'
            % SDMA (marigin%) (fastsmd) (marigin)
            % marigin%: Semi diameter margin
            % Marigin: Semi diameter margin meters
            % fastsmd : is 1 if “Fast Semi-Diameters” is selected otherwise it is 0.
            marginPercent = str2num(char(currentLineArray(2,:)));
            fastsmd = str2num(char(currentLineArray(3,:)));
            marigin = str2num(char(currentLineArray(4,:)));
            mySystem.SurfaceMarginPercent = marginPercent;
            mySystem.FastSemidiameter = fastsmd;
            mySystem.SurfaceMarginAdditional = marigin;
        case 'FTYP'
            % FTYP type ??0 nfieldpts nWavelength  fieldnorm ??0 ??0	: Field Type.
            % Type = 0,1,2,3 for Angle, Object Height, Paraxial Image Height, and Real Image Height respectively.
            % Nfieldpts: number of field points selected.
            % nWavelength : number of wavelengths selected.
            % Fieldnorm: 0,1 for Radial and Rectangular field normalization.
            ftype = str2num(char(currentLineArray(2,:)));
            if ftype == 0
                mySystem.FieldType = 'Angle';
            elseif ftype == 1
                mySystem.FieldType = 'ObjectHeight';
            else
                disp('Image height field value is not supported!! ');
                disp('Warning: Edit the field type.');
            end
            
            nfieldpts = str2num(char(currentLineArray(4,:)));
            mySystem.NumberOfFieldPoints = nfieldpts;
            mySystem.FieldPointMatrix = repmat([0,0,1],[nfieldpts,1]);
            
            nwavelengths = str2num(char(currentLineArray(5,:)));
            mySystem.NumberOfWavelengths = nwavelengths;
            mySystem.WavelengthMatrix = repmat([0,1],[nwavelengths,1]);
            
            fnorm = str2num(char(currentLineArray(6,:)));
            if fnorm == 0
                mySystem. FieldNormalization = 'Radial';
            else
                mySystem. FieldNormalization = 'Rectangular';
            end
        case 'XFLN'
            % XFLN val1 val2 val3...	The x field values (total 12)
            % number of field points defined
            nFieldPoint = mySystem.NumberOfFieldPoints;
            mySystem.FieldPointMatrix(:,1)= str2num(char((currentLineArray(2:nFieldPoint+1))));
        case 'YFLN'
            % YFLN val1 val2 val3...	The y field values (total 12)
            % number of field points defined
            nFieldPoint = mySystem.NumberOfFieldPoints;
            mySystem.FieldPointMatrix(:,2)= str2num(char((currentLineArray(2:nFieldPoint+1))));
        case 'FWGN'
            % FWGN val1 val2 val3...	Field weights (total 12)
            % number of field points defined
            nFieldPoint = mySystem.NumberOfFieldPoints;
            mySystem.FieldPointMatrix(:,3)= str2num(char((currentLineArray(2:nFieldPoint+1))));
            
        case 'GCAT'
            % GCAT name1 name2 name3 ...	Indicates which glass catalogs are used by the lens.
            % Future: Add function to import the glass catalogues on request
            disp(char(['Glass catalogues used:',(currentLineArray(2:end))']));
            
            % Check for the existance of the correspoding catalogues in
            % the toolbox.
            for kk = 2:size(currentLineArray,1)
                catName = [char(currentLineArray(kk,:)),'_AGF'];
                catFound = 0;
                for pp = 1:size(glassCatalogueListFullNames,1)
                    glassCatalogueListFullName = glassCatalogueListFullNames{pp};
                    [glassCataloguePath,glassCatalogueName,ext] = fileparts(glassCatalogueListFullName);
                    
                    if strcmpi(glassCatalogueName,catName)
                        catFound = 1;
                        break;
                    end
                end
                if ~catFound
                    % Construct a questdlg with three options
                    choice = questdlg(['The glass catalogue ',catName,' is not found. Do you want to continue ignoring the catalogue?'], ...
                        'Missing Glass Catalogue', ...
                        'Yes','Cancel','Yes');
                    % Handle response
                    switch choice
                        case 'Yes'
                            disp(['Warning: Missing glass catalogue. The glass catalogue :',catName,' is just ignored.']);
                        case 'Cancel'
                            disp(['Error: Missing glass catalogue. Please import the glass catalogue :',catName,' And retry.'])
                            return;
                    end
                end
            end
            %
            %
            %                 disp(['Warning: Currently automatic glass catalogue ',...
            %                     'importing is not supported. So please add the ',...
            %                     'corresponding glass catalogues manually .']);
        case 'GFAC'
            % GFAC val type	:Apodization factor value and type. The type code is 0
            % for none, 1 for Gaussian, and 2 for cosine cubed.
            apodVal = str2num(char(currentLineArray(2,:)));
            apodType = str2num(char(currentLineArray(3,:)));
            if apodType == 0
                mySystem.ApodizationType = 'None';
            elseif apodType == 1
                disp(['Warning: It is not possible to import Gaussian apodization parameters.']);
                % ApodizationType = 'Super Gaussian';
                % ApodizationParameters.MaximumIntensity =
                % ApodizationParameters.Order = 2;
                % ApodizationParameters.BeamRadius =
            else
                disp(['Warning: Cosine cubed apodization is not supported.']);
            end
        case 'GLRS'
            % GLRS surf f#comp	:Global Surface
            % Surf: index of global surface.
            % f#comp: 0,1 if method to compute F/# = “tracing rays” and “pupil size/position” respectively.
            disp(['Warning: Global reference surface is ignored and',...
                ' it is just fixed to the first surface.'])
        case 'MODE'
            % MODE SEQ	SEQ =  Sequential Mode or Hybrid
            % NSQ =  Non-sequential Mode
            mode = char(currentLineArray(2,:));
            if strcmpi(mode,'NSC')
                disp('Error: Non sequential system is not supported');
                return;
            end
        case 'NAME'
            % NAME name	: Name of the lens
            if size(currentLineArray,2) == 2
                mySystem.LensName = char(currentLineArray(2,:));
            else
                mySystem.LensName = 'Untitled';
            end
        case 'NOTE'
            % NOTE I Notes...	Notes related to the lens
            % I = {0, 4} ??
            if size(currentLineArray,1) == 3
                mySystem.LensNote = char(currentLineArray(3,:));
            end
        case 'NSCD'
            % NSCD maxInter maxSeg minAbsInt minRelInt maxObj glueDist
            % retrace ??0 ??0 ??0 misdRayDrawDist ??1 maxSrcRay simpRaySplit
            % ??2	: Non-sequential data
            % maxInter:maximum intersection per ray
            % maxSeg: maximum segments per ray
            % minAbsInt: minimum absolute ray intensity
            % minRelInt: minimum relative ray intensity
            % maxObj: maximum nested/touching objects
            % glueDist: glue distance in lens units
            % retrace: 1 if “Retrace source rays upon file open” is selected and 0 otherwise
            % ??0 ??0 ??0
            % misdRayDrawDist: missed ray draw distance in lens units
            % ??1
            % maxSrcRay: maximum source file rays in memory
            % simpRaySplit: 1 if “Simple ray splitting” is selected and 0 otherwise
            % ??2
            disp('Warning: All non sequential data are ignored.');
        case 'OBNA'
            % OBNA val I	I = 0:Object Space NA and I = 1: object cone angle
            value = str2num(char(currentLineArray(2,:)));
            I = str2num(char(currentLineArray(3,:)));
            if I == 0
                mySystem.SystemApertureType = 2;
                mySystem.SystemApertureValue = vlaue;
            else
                disp(['Warning: Object cone angle is not supported ',...
                    'so it is considered as object NA.']);
                mySystem.SystemApertureType = 2;
                mySystem.SystemApertureValue = vlaue;
            end
            
        case 'PICB'
            % PICB i	: Paraxial Ignore Coordinate Breaks,
            % i = 0 is false, i = 1 is true. Default is true.
            disp(['Warning: Paraxial Ignore Coordinate Breaks (PICB) is not supported.']);
        case 'POLS'
            % POLS unpol Ex Ey Phax Phay thinfilmtorayconvert refMethod :	Dafault polarization state used.
            % Unpol is 1 if “Unpolarized” is selected otherwise it is 0.
            % Thinfilmtorayconvert is 1 if “Convert thin film phase to ray equivalent” is selected otherwise it is 0.
            % refMethod is 0,1,2 for X-, Y- and Z-Axis reference method.
            unpol = str2num(char(currentLineArray(2,:)));
            Ex = str2num(char(currentLineArray(3,:)));
            Ey = str2num(char(currentLineArray(4,:)));
            Phax = str2num(char(currentLineArray(5,:)));
            Phay = str2num(char(currentLineArray(6,:)));
            thinfilmtorayconvert = str2num(char(currentLineArray(7,:)));
            refMethod = str2num(char(currentLineArray(8,:)));
            disp(['Warning: Default polarization state is not supported.']);
        case 'PUSH'
            % PUSH pupilshiftz pupilshifty pupilshiftx scalepupilshift pupilcompressx pupilcompressy	Pupil shift. All values indicate the corresponding values in the General system window.
            % Scalepupilshift is 1 if “Scale Pupil Shift factors by field” is selected else it is 0.
            disp(['Warning: Pupil Shift (PUSH) is not supported.']);
        case 'RAIM'
            % RAIM tol type ?? fastasphere usecache grinaper robust
            % threadingoff dontprintcoordbreak opd2modpi	: The ray aiming and a few other settings.
            % Fastasphere is 1
            % if the "Fast Asphere Trace" is selected, otherwise it is
            % 0.
            % Threadingoff is 1 if “Turn Off Threading” is selected, otherwise 0.
            % Grinaper is 1 if "Check Grin
            % Aper" is selected, otherwise it is 0.
            % Dontprintcoordbreak is 1 if “Don’t Print Coordinate Break Data” is selected, otherwise 0.
            % Tol is
            % no longer used, but some value (such as zero) must
            % be present as a placeholder.
            % Type is 0, 1, or 2 for
            % None, Paraxial, or Real ray aiming.
            % opd2modpi is 1 if “OPD Modulo 2 pi” is selected, otherwise 0.
            %
            % Usecache is 1 if "Use Ray Aiming Cache" is
            % selected, otherwise it is 0.
            % Robust is 1 if
            % "Robust Ray Aiming" is selected, otherwise it is 0.
            disp(['Warning: Ray aim (RAIM) is not supported.']);
        case 'ROPD'
            % ROPD i	Reference OPD setting. For i = 0, 1, 2, and 3, the
            % reference point is Absolute, Infinity,Exit Pupil, and Absolute 2 respectively. Use Exit Pupil as the default.
            disp(['Warning: The reference OPD setting is ignored. ',...
                'It is usually at Exit pupil.']);
        case 'SCAT'
            % SCAT model fraction angle ??“”	Scattering
            % Model: Scattering model. 0(No Scattering),1(Lamberitian),2(Gaussian),3(ABg),4(ABg file),5(BSDF),6(IS Scatter Catalogue),7(User Defined)
            % Fraction: Scatter fraction
            % Angle: Angle
            % ??“”
            disp(['Warning: Scaterring data (SCAT) is not supported.']);
        case 'UNIT'
            % UNIT LensUnit SourceUnitPrefix SourceUnit
            % AnalysisUnitPrefix AnalysisUnit AfocalModeUnit
            % MTFUnit
            % LensUnit {MM,CM,IN,METER}
            % SourceUnitPrefix {F,P,N,U,M,X,K,E,G,T}
            % SourceUnit{W,L,J}
            % AnalysisUnitPrefix{F,P,N,M,G}
            % AnalysisUnit{MM,CM,IN,ME,FT}
            % AfocalModeUnit{UR,MR,RR,AS,AM,DG}
            % MTFUnit{CPMM,CPMR}
            %
            LENSUNIT = char(currentLineArray(2,:));
            if strcmpi(LENSUNIT,'MM')
                lensUnit = 1;
            elseif strcmpi(LENSUNIT,'CM')
                lensUnit = 2;
            elseif strcmpi(LENSUNIT,'IN')
                lensUnit = 2; % for now take IN as CM
                disp('Error: IN is not supported as lens units so it is taken as CM');
            elseif strcmpi(LENSUNIT,'METER')
                lensUnit = 3;
            else
            end
            wavUnit = 2; % Wavelength is always in microns in ZMX
            
            mySystem.WavelengthUnit = wavUnit;
            mySystem.LensUnit = lensUnit;
            
            disp(['Warning: Only lens and wavelength units are supported.']);
        case {'VANN','VCXN','VCYN','VDXN','VDYN'}
            % VANN val1 val2 val3...	VAN vignating factors (total 12)
            disp('Warning: Vignating factors are not supported.');
        case 'WAVM'
            % WAVM N wavlen weight	: Wavelength
            % N = 1,2,…24 indicating the wavelength index
            % Wavlen: the waveleght value
            % Weight: corresponding weight
            nwav = mySystem.NumberOfWavelengths;
            N = str2num(char(currentLineArray(2,:)));
            wavlen = str2num(char(currentLineArray(3,:)));
            weight = str2num(char(currentLineArray(4,:)));
            if N <= nwav
                mySystem.WavelengthMatrix(N,1) = wavlen;
                mySystem.WavelengthMatrix(N,2) = weight;
            end
        case 'PWAV'
            % PWAV ind	: Primary wavelength index (starts from 1).
            mySystem.PrimaryWavelengthIndex = str2num(char(currentLineArray(2,:)));
        case 'SURF'
            % SURF index	Surface index starting from 0 @ object surface.
            disp('Completed: Importing system configuration data.');
            disp(' ');
            disp('Started: Importing surface data...');
            [surfArray,nonDummySurfaceIndices,nextZmxCommand] = readSurfaceArray(inputFile,...
                coatingCatalogueListFullNames,glassCatalogueListFullNames,mySystem);
            
            mySystem.SurfaceArray = surfArray;
            mySystem.NumberOfSurfaces = length(surfArray);
            mySystem.NonDummySurfaceArray  = surfArray(nonDummySurfaceIndices);
            mySystem.NumberOfNonDummySurfaces = length(nonDummySurfaceIndices);
            mySystem.NonDummySurfaceIndices = nonDummySurfaceIndices;
            
            % Skip readLine for the next command as it is already read
            % by the readSurfaceArray function
            skipNextLineRead = 1;
            disp('Completed: Importing surface data.');
            disp(' ');
        case 'MFDS'
            disp('Started: Importing Merit function data...');
            [meritFunction,nextZmxCommand] = readMeritFunction(inputFile);
            % Skip readLine for the next command as it is already read
            % by the readMeritFunction function
            skipNextLineRead = 1;
            disp('Completed: Importing Merit function data.');
            disp(' ');
        case 'MNUM'
            % MNUM n ??1	Number of configuration
            disp('Started: Importing Multi-configuration data...');
            [multiConfigData,nextZmxCommand] = readMultiConfigurationData(inputFile);
            % Skip readLine for the next command as it is already read
            % by the readMultiConfigurationData function
            skipNextLineRead = 1;
            disp('Completed: Importing Multi-configuration data.');
            disp(' ');
        case 'TOL'
            disp('Started: Importing Tolerance data...');
            [toleranceData,nextZmxCommand] = readToleranceData(inputFile);
            % Skip readLine for the next command as it is already read
            % by the readToleranceData function
            skipNextLineRead = 1;
            disp('Completed: Importing Tolerance data.');
            disp(' ');
    end
    % read the next valid line
    if skipNextLineRead
        currentLine = nextZmxCommand;
        skipNextLineRead = 0;
    else
        currentLine = readNextLine(inputFile);
    end
end
nSurf = size(mySystem.SurfaceArray,2);
mySystem.NumberOfSurfaces =  nSurf;
mySystem.SurfaceArray(1).ObjectSurface = 1;
mySystem.SurfaceArray(nSurf).ImageSurface = 1;

% 
% Save all surfaces as components SS
nComponent = mySystem.NumberOfSurfaces;
mySystem.NumberOfComponents = nComponent;
for kk = 1:nComponent   
    mySystem.ComponentArray(kk).Type = 'SS';
    mySystem.ComponentArray(kk).Parameters.NumberOfSurfaces = 1;
    mySystem.ComponentArray(kk).Parameters.SurfaceArray = mySystem.SurfaceArray(kk);     
end
   
opticalSystemObject = mySystem;
end

%%%%%%%%%%%%%%%%%%%%%%%
function nextLine =  readNextLine(inputFile)
line = (fgets(inputFile));
if ischar(line)
    nxtL = strtrim(line);
    % nxtL(2:2:length(nxtL)) = '';
    if length(line)< 3
        % invalid line just skip
        disp('Error: Invalid zmx command line found.');
        nextLine =  readNextLine(inputFile);
    end
else
    nxtL = 'EOF';
end

nextLine = nxtL;

end

%%%%%%%%%%%%%%%%%%%%%%%
function [meritFunction,nextZmxCommand] = readMeritFunction(inputFile)
disp('Currently merit functions can not be imported. So all are just ignored');
% Ignore all lines of text, until we see one that just consists of this:
% {'MNUM','TOL','CSUM'}
while 1
    currentLine = readNextLine(inputFile);
    % read the line as space separated string
    currentLineArray = strread(currentLine,'%s');
    % The first element of the array is the 4 character zmx command
    zmxSurfCommand = char(currentLineArray(1,:));
    
    % Break if we hit end of file, or the start marker
    if ~ischar(currentLine)  ||  strcmp(zmxSurfCommand, 'MNUM')...
            ||  strcmp(zmxSurfCommand, 'TOL') ||strcmp(zmxSurfCommand, 'CSUM')
        break
    end
end
meritFunction = 'No merit function';
nextZmxCommand = zmxSurfCommand;
end

%%%%%%%%%%%%%%%%%%%%%%%
function [multiConfigData,nextZmxCommand] = readMultiConfigurationData(inputFile)
disp('Currently multi-configuration data can not be imported. So all are just ignored');
% Ignore all lines of text, until we see one that just consists of
% this:{'MFDS', 'TOL','CSUM'}
while 1
    currentLine = readNextLine(inputFile);
    % read the line as space separated string
    currentLineArray = strread(currentLine,'%s');
    % The first element of the array is the 4 character zmx command
    zmxSurfCommand = char(currentLineArray(1,:));
    
    % Break if we hit end of file, or the start marker
    if ~ischar(currentLine)  ||  strcmp(zmxSurfCommand, 'MFDS')...
            ||  strcmp(zmxSurfCommand, 'TOL') ||strcmp(zmxSurfCommand, 'CSUM')...
            ||strcmp(zmxSurfCommand, 'EOF')
        break
    end
end
multiConfigData = 'No multi configuration data';
nextZmxCommand = zmxSurfCommand;
end

%%%%%%%%%%%%%%%%%%%%%%%
function [toleranceData,nextZmxCommand] = readToleranceData(inputFile)
disp('Currently tolerance data can not be imported. So all are just ignored');
% Ignore all lines of text, until we see one that just consists of
% this:{'MFDS', 'MNUM','CSUM'}
while 1
    currentLine = readNextLine(inputFile);
    % read the line as space separated string
    currentLineArray = strread(currentLine,'%s');
    % The first element of the array is the 4 character zmx command
    zmxSurfCommand = char(currentLineArray(1,:));
    
    % Break if we hit end of file, or the start marker
    if ~ischar(currentLine)  ||  strcmp(zmxSurfCommand, 'MFDS')...
            ||  strcmp(zmxSurfCommand, 'MNUM') ||strcmp(zmxSurfCommand, 'CSUM')
        break
    end
end
toleranceData = 'No Tolerance Data';
nextZmxCommand = zmxSurfCommand;
end

%%%%%%%%%%%%%%%%%%%%%%%
function [surfaceObjectArray,nonDummySurfaceIndices,nextZmxCommand] = readSurfaceArray(inputFile,...
    coatingCatalogueListFullNames,glassCatalogueListFullNames,mySystem)
surfaceCounter = 1;
nonDummySurface = ones(1,100);
surfaceObjectArray(surfaceCounter) = Surface;

currentLine = readNextLine(inputFile);
% read the line as space separated string
currentLineArray = strread(currentLine,'%s');
% The first element of the array is the 4 character zmx command
zmxSurfCommand = char(currentLineArray(1,:));
validSurfaceCommand = 1;

while validSurfaceCommand
    switch zmxSurfCommand
        case 'HIDE'
            % HIDE hideRays noEdgesDraw noSurfDraw rowColor noHyperHemisph
            % surfIgnore edgeDrawType skipRays drawLocalAx ??0
            % Setting to show/hide surface comps.
            % hideRays: is 1 if “Hide Rays To This Surface” is selected otherwise is 0.
            % noEdgesDraw: is 1 if “Don’t Draw Edges From This Surface” is selected otherwise is 0.
            % noSurfDraw: is 1 if “Don’t Draw This Surface” is selected otherwise is 0.
            % rowColor: 0(Default),1(Color 1),…,24(color 24),25(no color).
            % noHyperHemisph: is 1 if “Surface Can’t Be Hyperhemispheric” is selected otherwise is 0.
            % surfIgnore: is 1 if “Ignore This Surface” is selected otherwise is 0.
            % edgeDrawType: 0(Squared to Next Surface),1(Tapered To Next Surface),2(Flat To Next Surface)
            % skipRays: is 1 if “Skip Rays To This Surface” is selected otherwise is 0.
            % drawLocalAx: is 1 if “Draw Local Axis” is selected otherwise is 0.
            %  ??0
            disp(['Surf ',num2str(surfaceCounter),' Warning: Hide setting (HIDE) is not supported.']);
        case 'POPS'
            % POPS autoResample useRays don'tRescaleBeamSize UseAngSpectProp OutputPilotRad DrawBeamFile Resample XSamp 1=32,2=64,...) YSamp XWidth  YWidth ??0 XRad YRad useXAxisRef	Physical optics propagation data
            % autoResample: is 1 if “Auto Resample” is selected and 0 otherwise.
            % useRays: is 1 if “Use Rays To Propagate To Next Surface” is selected and 0 otherwise.
            % don'tRescaleBeamSize: is 1 if “Don not Rescale Beam Size Using Ray Data” is selected and 0 otherwise.
            % UseAngSpectProp: is 1 if “Use Angular Spectrum Propagator” is selected and 0 otherwise.
            % OutputPilotRad: 0:Best fit 1:shorter 2:longer 3:X 4:Y 5:Plane 6:User
            % DrawBeamFile: is 1 if “Draw Beamfile On Shaded Model” is selected and 0 otherwise.
            % Resample: is 1 if “Resample After Refraction” is selected and 0 otherwise.
            % XSamp: X-Sampling 1=32,2=64,...10=16384
            % YSamp: Y-Sampling 1=32,2=64,...10=16384
            % XWidth: X-Width
            % YWidth: Y-Width
            % ??0
            % XRad: X-Radius
            % YRad: Y-Radius
            % useXAxisRef: is 1 if “Use X-Axis Reference” is selected and 0 otherwise.
            disp(['Surf ',num2str(surfaceCounter),' Warning: Physical Optics Propagation (POPS) is not supported.']);
        case 'MIRR'
            % MIRR substShape substThick	The mirror substrate.
            % substShape: 0(None),1(Flat),2(Curved)
            % substThick: substrate thickness
            disp(['Surf ',num2str(surfaceCounter),' Warning: Mirror substrate data (MIRR) is not supported. It is always curved.']);
        case 'CLAP'
            % CLAP min max surfPickup	:Circular Aperture min and max radius. Index of Pickup surface otherwise 0.
            min = str2num(char(currentLineArray(2,:)));
            max = str2num(char(currentLineArray(3,:)));
            surfPickup = str2num(char(currentLineArray(4,:)));
            
            % Use the max value as radius
            surfaceObjectArray(surfaceCounter).ApertureType = 'Circular';
            aperParam = surfaceObjectArray(surfaceCounter).ApertureParameter;
            
            if strcmpi(zemaxSurfaceType,'TILTSURF')
                % For tilt surface the semidiameter and aperture values
                % given in zemax are not the actual values rather they
                % are projections on x and y plane. So shall be converted
                % to actual values.
                tiltX = surfaceObjectArray(surfaceCounter).TiltParameter(1);
                tiltY = surfaceObjectArray(surfaceCounter).TiltParameter(2);
                apertureFactorX = abs(1/cos(tiltY*pi/180));
                apertureFactorY = abs(1/cos(tiltX*pi/180));
            else
                apertureFactorX = 1;
                apertureFactorY = 1;
            end
            
            aperParam(1) = max*apertureFactorX;
            aperParam(2) = max*apertureFactorY;
            
            surfaceObjectArray(surfaceCounter).ClearAperture = 1;
            surfaceObjectArray(surfaceCounter).AdditionalEdge = mySystem.SurfaceMarginPercent/100;
            
            surfaceObjectArray(surfaceCounter).ApertureParameter = aperParam;
            disp(['Surf ',num2str(surfaceCounter),' Warning: Min and Max values for circular aperture '...
                'is not supported. Only the Max value is considered' ]);
            if surfPickup
                disp(['Surf ',num2str(surfaceCounter),' Warning: Surface '...
                    'aperture pickup is not supported.' ]);
            end
            
        case 'ELAP'
            % ELAP xHalfWid yHalfWid surfPickup	: Elliptical aperture x and y half width. Index of Pickup surface otherwise 0.
            xHalfWid = str2num(char(currentLineArray(2,:)));
            yHalfWid = str2num(char(currentLineArray(3,:)));
            surfPickup = str2num(char(currentLineArray(4,:)));
            
            % Use the max value as radius
            surfaceObjectArray(surfaceCounter).ApertureType = 'Elliptical';
            aperParam = surfaceObjectArray(surfaceCounter).ApertureParameter;
            
            if strcmpi(zemaxSurfaceType,'TILTSURF')
                % For tilt surface the semidiameter and aperture values
                % given in zemax are not the actual values rather they
                % are projections on x and y plane. So shall be converted
                % to actual values.
                tiltX = surfaceObjectArray(surfaceCounter).TiltParameter(1);
                tiltY = surfaceObjectArray(surfaceCounter).TiltParameter(2);
                apertureFactorX = abs(1/cos(tiltY*pi/180));
                apertureFactorY = abs(1/cos(tiltX*pi/180));
            else
                apertureFactorX = 1;
                apertureFactorY = 1;
            end
            
            aperParam(1) = xHalfWid*apertureFactorX;
            aperParam(2) = yHalfWid*apertureFactorY;
            
            surfaceObjectArray(surfaceCounter).ClearAperture = 1;
            surfaceObjectArray(surfaceCounter).AdditionalEdge = mySystem.SurfaceMarginPercent/100;
            
            surfaceObjectArray(surfaceCounter).ApertureParameter = aperParam;
            if surfPickup
                disp(['Surf ',num2str(surfaceCounter),' Warning: Surface '...
                    'aperture pickup is not supported.' ]);
            end
        case 'ELOB'
            % ELOB xHalfWid yHalfWid surfPickup	: Elliptical aperture x and y half width. Index of Pickup surface otherwise 0.
            disp(['Surf ',num2str(surfaceCounter),'Error: Obscuration '...
                'aperture is not supported.' ]);
        case 'FLAP'
            % FLAP 0 semiDiam surfPickup	: Floating Aperture
            % semiDiam: Semi-diameter
            % surfPickup: Index of Pickup surface otherwise 0.
            semiDiam = str2num(char(currentLineArray(3,:)));
            surfPickup = str2num(char(currentLineArray(4,:)));
            
            % Use the max value as radius
            surfaceObjectArray(surfaceCounter).ApertureType = 'Floating';
            aperParam = surfaceObjectArray(surfaceCounter).ApertureParameter;
            
            if strcmpi(zemaxSurfaceType,'TILTSURF')
                % For tilt surface the semidiameter and aperture values
                % given in zemax are not the actual values rather they
                % are projections on x and y plane. So shall be converted
                % to actual values.
                tiltX = surfaceObjectArray(surfaceCounter).TiltParameter(1);
                tiltY = surfaceObjectArray(surfaceCounter).TiltParameter(2);
                apertureFactorX = abs(1/cos(tiltY*pi/180));
                apertureFactorY = abs(1/cos(tiltX*pi/180));
            else
                apertureFactorX = 1;
                apertureFactorY = 1;
            end
            
            aperParam(1) = semiDiam*apertureFactorX;
            aperParam(2) = semiDiam*apertureFactorY;
            
            surfaceObjectArray(surfaceCounter).ClearAperture = 1;
            surfaceObjectArray(surfaceCounter).AdditionalEdge = mySystem.SurfaceMarginPercent/100;
            
            surfaceObjectArray(surfaceCounter).ApertureParameter = aperParam;
            if surfPickup
                disp(['Surf ',num2str(surfaceCounter),' Warning: Surface '...
                    'aperture pickup is not supported.' ]);
            end
            
        case 'OBDC'
            % OBDC xdec ydec	Aperture and Obscuration decenter in x and y direction.
            xdec = str2num(char(currentLineArray(2,:)));
            ydec = str2num(char(currentLineArray(3,:)));
            aperParam = surfaceObjectArray(surfaceCounter).ApertureParameter;
            aperParam(3) = xdec;
            aperParam(4) = ydec;
            surfaceObjectArray(surfaceCounter).ApertureParameter = aperParam;
        case 'OBSC'
            % OBSC min max surfPickup	Circular Obscuration min and max radius. Index of Pickup surface otherwise 0.
            disp(['Surf ',num2str(surfaceCounter),'Error: Obscuration '...
                'aperture is not supported.' ]);
        case 'SPID'
            % SPID widArms numbArms surfPickup	Spider width of Arm and number of arms. Index of Pickup surface otherwise 0.
            disp(['Surf ',num2str(surfaceCounter),'Error: Spider '...
                'aperture is not supported.' ]);
        case 'SQAP'
            % SQAP xHalfWid yHalfWid surfPickup	Rectangular aperture x and y half width. Index of Pickup surface otherwise 0.
            xHalfWid = str2num(char(currentLineArray(2,:)));
            yHalfWid = str2num(char(currentLineArray(3,:)));
            surfPickup = str2num(char(currentLineArray(4,:)));
            
            % Use the max value as radius
            surfaceObjectArray(surfaceCounter).ApertureType = 'Rectangular';
            aperParam = surfaceObjectArray(surfaceCounter).ApertureParameter;
            
            if strcmpi(zemaxSurfaceType,'TILTSURF')
                % For tilt surface the semidiameter and aperture values
                % given in zemax are not the actual values rather they
                % are projections on x and y plane. So shall be converted
                % to actual values.
                tiltX = surfaceObjectArray(surfaceCounter).TiltParameter(1);
                tiltY = surfaceObjectArray(surfaceCounter).TiltParameter(2);
                apertureFactorX = abs(1/cos(tiltY*pi/180));
                apertureFactorY = abs(1/cos(tiltX*pi/180));
            else
                apertureFactorX = 1;
                apertureFactorY = 1;
            end
            
            aperParam(1) = xHalfWid*apertureFactorX;
            aperParam(2) = yHalfWid*apertureFactorY;
            
            surfaceObjectArray(surfaceCounter).ClearAperture = 1;
            surfaceObjectArray(surfaceCounter).AdditionalEdge = mySystem.SurfaceMarginPercent/100;
            
            surfaceObjectArray(surfaceCounter).ApertureParameter = aperParam;
            if surfPickup
                disp(['Surf ',num2str(surfaceCounter),' Warning: Surface '...
                    'aperture pickup is not supported.' ]);
            end
        case 'SQOB'
            % SQOB xHalfWid yHalfWid surfPickup	Rectangular Obscuration x and y half width. Index of Pickup surface otherwise 0.
            disp(['Surf ',num2str(surfaceCounter),'Error: Obscuration '...
                'aperture is not supported.' ]);
        case 'UDAD'
            % UDAD I x y z	User defined aperture data. The first line is always <UDAD 0 “name.uda” UDAsclae>, then for I = 1,2,… the x and y data points corresponding to the user defined aperture are presented.
            disp(['Surf ',num2str(surfaceCounter),'Error: User defined '...
                'aperture is not supported.' ]);
        case 'USAP'
            % USAP min max surfPickup	User aperture. Index of Pickup surface otherwise 0.
            disp(['Surf ',num2str(surfaceCounter),'Error: User defined '...
                'aperture is not supported.' ]);
        case 'USOB'
            % USOB min max surfPickup	User Obscuration.
            disp(['Surf ',num2str(surfaceCounter),'Error: Obscuration '...
                'aperture is not supported.' ]);
            
        case 'COAT'
            % COAT name :	The name of coating (if any)
            disp(['Surf ',num2str(surfaceCounter),' Warning: Importing '...
                'coating is not fully supported. Needs checking.' ]);
            % coating data
            coatName = char(currentLineArray(2,:));
            if ~isempty(coatName)
                % check for its existance and extract the coating among selected catalogues
                objectType = 'coating';
                objectName = coatName;
                
                objectCatalogueListFullNames = coatingCatalogueListFullNames;
                objectIndex = 0;
                for pp = 1:size(objectCatalogueListFullNames,1)
                    objectCatalogueFullName = objectCatalogueListFullNames{pp};
                    [ aodObject,objectIndex ] = extractObjectFromAODObjectCatalogue...
                        (objectType,objectName,objectCatalogueFullName );
                    if objectIndex ~= 0
                        break;
                    end
                end
                
                if  objectIndex ~= 0
                    surfaceObjectArray(surfaceCounter).Coating = aodObject;
                else
                    disp(['Error: The coating of surface ',num2str(surfaceCounter),' is not found so it is ignored.']);
                    surfaceObjectArray(surfaceCounter).Coating = Coating;
                end
            else
                surfaceObjectArray(surfaceCounter).Coating = Coating;
            end
            
        case 'COMM'
            % COMM comment	Comment on the surface.
            surfaceObjectArray(surfaceCounter).Comment = (char(currentLineArray(2,:)));
        case 'CONI'
            % CONI val	Conic constant of the surface.
            conic = str2num(char(currentLineArray(2,:)));
            surfaceObjectArray(surfaceCounter).OtherStandardData.ConicConstant = conic;
        case 'VCON'
            % VCON	Variable conic constant.
            disp(['Surf ',num2str(surfaceCounter),' Warning: Conic '...
                'constant solve/pickup is not supported.' ]);
        case 'PKUP'
            % PKUP Surf scale Col	Conic Constant pickup.
            % Surf: From Surface index
            % Scale: Scale factor
            % Col: Pickup Column. 0(current),1(radius),2(thickness),3(conic),4(semidiameter),5(
            disp(['Surf ',num2str(surfaceCounter),' Warning: Conic '...
                'constant solve/pickup is not supported.' ]);
        case 'CURV'
            % CURV val solveType param1 param2 param3 param4	The surface curvature.
            % Val: value of the curvature
            % solveType = 0 (fixed), 1(variable),2,3,… indicating the solve types (see the solves chapter from Zemax manual)
            % param1…4 : Solve parameters
            %
            curv = str2num(char(currentLineArray(2,:)));
            solve = str2num(char(currentLineArray(3,:)));
            surfaceObjectArray(surfaceCounter).OtherStandardData.Radius = 1/curv;
            if solve
                disp(['Surf ',num2str(surfaceCounter),' Warning: Surface '...
                    'curvature solve/pickup is not supported.' ]);
            end
        case 'SCOL'
            % SCOL colIndex transparency	Surface Color.
            % colIndex: 0(default), 1-24(d/t color index)
            % transparency: (100 - Surface Opacity%)/10
            disp(['Surf ',num2str(surfaceCounter),' Warning: Surface '...
                'color is not supported.' ]);
        case 'SLAB'
            % SLAB val	Surface labels.
            % Val: unique integer assigned to each surface to identify the surface as new surfaces are inserted or old ones deleted. This can be used to know where a surface has moved to in the list of surfaces.
            disp(['Surf ',num2str(surfaceCounter),' Warning: Surface '...
                'label is not supported.' ]);
        case 'STOP'
            % STOP	Marks Stop Surface.
            surfaceObjectArray(surfaceCounter).Stop = 1;
        case 'SURF'
            % SURF index	Surface index starting from 0 @ object surface.
            surfaceCounter = surfaceCounter + 1;
            surfaceObjectArray(surfaceCounter) = Surface;
            disp(' ');
            
        case 'TYPE'
            % TYPE surfType: 	surfType = STANDARD,EVENASPH,ODDASPHE...
            % Surface types supported are STANDARD, TILTSURF, DGRATING,
            % COORDBRK.
            % STANDARD, TILTSURF, DGRATING => Standard
            % COORDBRK => Dummy
            
            zemaxSurfaceType = char(currentLineArray(2,:));
            if strcmpi(zemaxSurfaceType,'STANDARD')||...
                    strcmpi(zemaxSurfaceType,'TILTSURF')||...
                    strcmpi(zemaxSurfaceType,'DGRATING')
                surfaceObjectArray(surfaceCounter).Type = 'Standard';        
            elseif strcmpi(zemaxSurfaceType,'COORDBRK')
                surfaceObjectArray(surfaceCounter).Type = 'Dummy';
                nonDummySurface(surfaceCounter) = 0;
            else
                disp(['Surf ',num2str(surfaceCounter),' Warning: Surface '...
                    'type: ',zemaxSurfaceType,' is not supported. It is cosidered as STANDARD' ]);
                surfaceObjectArray(surfaceCounter).Type = 'Standard';
            end           
            % Initialize all surface specific data
            % Other surface type specific standard data
            [fieldNames,fieldFormat,initialData] = surfaceObjectArray(surfaceCounter).getOtherStandardDataFields;
            surfaceObjectArray(surfaceCounter).OtherStandardData = struct;
            for ff = 1:10
                surfaceObjectArray(surfaceCounter).OtherStandardData.(fieldNames{ff}) = ...
                (initialData{ff});
            end 
        
        case 'GLAS'
            % GLAS name code psurf nd vd pd vnd vvd vpd io ao	Glass
            % name: The name of the glass or "___BLANK" if glass name is not given or "MIRROR" if mirror.
            % code: The glass type used. 0(Fixed or Mirror),1(Model),2(Pickup),3(Substitute),4(Offset)
            % psurf: Pickup Surface index. Only used for pickup surfaces and 0 otherwise.
            % nd,vd and pd: The index, abbe number and partial disperssion for the glass (but used only for model glass).
            % vnd,vvd and vpd: Variablity status of nd,vd and pd.
            % io and ao: Offset values (index offset and abbe offset)
            
            disp(['Surf ',num2str(surfaceCounter),' Warning: Importing '...
                'glass is not fully supported.Needs checking.' ]);
            name = char(currentLineArray(2,:));
            code = str2num(char(currentLineArray(3,:)));
            psurf = str2num(char(currentLineArray(4,:)));
            nd = str2num(char(currentLineArray(5,:)));
            vd = str2num(char(currentLineArray(6,:)));
            pd = str2num(char(currentLineArray(7,:)));
            vnd = str2num(char(currentLineArray(8,:)));
            vvd = str2num(char(currentLineArray(9,:)));
            vpd = str2num(char(currentLineArray(10,:)));
            io = str2num(char(currentLineArray(11,:)));
            ao = str2num(char(currentLineArray(12,:)));
            
            if strcmpi(name,'MIRROR')
                aodObject = Glass('MIRROR','FixedIndex',[1,0,0,0,0,0,0,0,0,0]');
                surfaceObjectArray(surfaceCounter).Glass = aodObject;
                
                % Just take the glass of the non dummy surface before the mirror
                % but with the new name "MIRROR"
                for pp = surfaceCounter-1:-1:1
                    if nonDummySurface(pp)
                        prevNonDummySurface = pp;
                        break;
                    end
                end
                aodObject = surfaceObjectArray(prevNonDummySurface).Glass;
                aodObject.Name = 'MIRROR';
                surfaceObjectArray(surfaceCounter).Glass = aodObject;
                
            else
                % glasss data
                % get glass name and then SellmeierCoefficients from file
                glassName = char(currentLineArray(2,:));
                if ~isempty(glassName)
                    if ~strcmpi(glassName,'___BLANK')
                        % check for its existance and extract the glass among selected catalogues
                        objectType = 'glass';
                        objectName = glassName;
                        if isnan(str2double(glassName)) % If the glass name is specified
                            objectCatalogueListFullNames = glassCatalogueListFullNames;
                            objectIndex = 0;
                            for pp = 1:size(objectCatalogueListFullNames,1)
                                objectCatalogueFullName = objectCatalogueListFullNames{pp};
                                [ aodObject,objectIndex ] = extractObjectFromAODObjectCatalogue...
                                    (objectType,objectName,objectCatalogueFullName );
                                if objectIndex ~= 0
                                    break;
                                end
                            end
                            
                            if  objectIndex ~= 0
                                surfaceObjectArray(surfaceCounter).Glass = aodObject;
                            else
                                disp(['Error: The glass after surface ',num2str(surfaceCounter),' is not found so it is ignored.']);
                                surfaceObjectArray(surfaceCounter).Glass = Glass;
                            end
                        else
                            aodObject = Glass(glassName);
                            surfaceObjectArray(surfaceCounter).Glass = aodObject;
                        end
                    else
                        if code == 1 % Model  / fixed index glass
                            glassName = [num2str((nd),'%.4f '),',',...
                                num2str((vd),'%.4f '),',',...
                                num2str((pd),'%.4f ')];
                            aodObject = Glass(glassName,'FixedIndex',[nd,vd,pd,0,0,0,0,0,0,0]');
                            surfaceObjectArray(surfaceCounter).Glass = aodObject;
                        end
                    end
                else
                    surfaceObjectArray(surfaceCounter).Glass = Glass;
                end
            end
            
            
        case 'DIAM'
            % DIAM val solveType param1 param2 param3 param4	The surface semidiameter.
            % Val: value of the semidiameter
            % solveType = 0 (automatic), 1(fixed),2(pickup),3(maximum),4(zpl macro)… indicating the solve types (see the solves chapter from Zemax manual)
            % param1…4 : Solve parameters
            %
            semidiam = str2num(char(currentLineArray(2,:)));
            solveType = str2num(char(currentLineArray(3,:)));
            %             surfaceObjectArray(surfaceCounter).SemiDiameter = semidiam;
            
            if solveType
                disp(['Surf ',num2str(surfaceCounter),' Warning: Semidiameter '...
                    ' solve/pickup is not supported.' ]);
            end
            
            % Set the aperture values if it is floating or None
            if strcmpi(surfaceObjectArray(surfaceCounter).ApertureType,'Floating')||...
                    strcmpi(surfaceObjectArray(surfaceCounter).ApertureType,'None')
                aperParam = surfaceObjectArray(surfaceCounter).ApertureParameter;
                if strcmpi(zemaxSurfaceType,'TILTSURF')
                    % For tilt surface the semidiameter and aperture values
                    % given in zemax are not the actual values rather they
                    % are projections on x and y plane. So shall be converted
                    % to actual values.
                    tiltX = surfaceObjectArray(surfaceCounter).TiltParameter(1);
                    tiltY = surfaceObjectArray(surfaceCounter).TiltParameter(2);
                    apertureFactorX = abs(1/cos(tiltY*pi/180));
                    apertureFactorY = abs(1/cos(tiltX*pi/180));
                else
                    apertureFactorX = 1;
                    apertureFactorY = 1;
                end
                aperParam(1) = semidiam*apertureFactorX;
                aperParam(2) = semidiam*apertureFactorY;
                
                % Add the margins and Set clear aperture
                aperParam(1) = aperParam(1);
                aperParam(2) = aperParam(2);
                surfaceObjectArray(surfaceCounter).ClearAperture = 1;
                surfaceObjectArray(surfaceCounter).AdditionalEdge = mySystem.SurfaceMarginPercent/100;
                
                surfaceObjectArray(surfaceCounter).ApertureParameter = aperParam;
            end
            
        case  'DISZ'
            % DISZ val: The Z thickness of the surface.
            thick = (char(currentLineArray(2,:)));
            if strcmpi(thick,'INFINITY')|| strcmpi(thick,'INF')
                thick = Inf;
            else
                thick = str2num(thick);
            end
            surfaceObjectArray(surfaceCounter).Thickness = thick;
        case {'CHZH', 'EDGE','MAZH','OPDZ' ,'PZUP' ,...
                'TCOC','TCOM' ,'TOLE','TPUP','VDSZ'}
            disp(['Surf ',num2str(surfaceCounter),' Warning: Thickness '...
                ' solve/pickup is not supported.' ]);
        case 'SCBD'
            % SCBD beforeAfter order pickupType decX decY tiltX tiltY tiltZ	SCBD => ??TILT AND DECENTER DATA
            % beforeAfter: 1(before surface) , 2(after surface)
            % order: 0(Decenter,Tilt), 1(Tilt,Decenter)
            % pickupType:0(Explicit), 1(Pick This Surf), 2(Reverse This Surf), 3(Pick This Surf-1), 4(Reverse This Surf-1),..., 2n+1(Pick Surf - n), 2n+2(Reverse Surf - n )
            % decX decY tiltX tiltY tiltZ
            disp(['Error: Tilt and decenter data for surface is not currently',...
                ' supported. Please use Coordinate break surface instead.']);
        case 'PARM'
            % PARM n val	Parameter n is the value of "val".
            n = str2num(char(currentLineArray(2,:)));
            value = str2num(char(currentLineArray(3,:)));
            if  strcmpi(zemaxSurfaceType,'COORDBRK')
                switch n
                    case 1
                        decParam = surfaceObjectArray(surfaceCounter).DecenterParameter;
                        decParam(1) = value;
                        surfaceObjectArray(surfaceCounter).DecenterParameter = decParam;
                    case 2
                        decParam = surfaceObjectArray(surfaceCounter).DecenterParameter;
                        decParam(2) = value;
                        surfaceObjectArray(surfaceCounter).DecenterParameter = decParam;
                    case 3
                        tiltParam = surfaceObjectArray(surfaceCounter).TiltParameter;
                        tiltParam(1) = value;
                        surfaceObjectArray(surfaceCounter).TiltParameter = tiltParam;
                    case 4
                        tiltParam = surfaceObjectArray(surfaceCounter).TiltParameter;
                        tiltParam(2) = value;
                        surfaceObjectArray(surfaceCounter).TiltParameter = tiltParam;
                    case 5
                        tiltParam = surfaceObjectArray(surfaceCounter).TiltParameter;
                        tiltParam(3) = value;
                        surfaceObjectArray(surfaceCounter).TiltParameter = tiltParam;
                    case 6
                        order = value;
                        if order == 0 % D->T
                            surfaceObjectArray(surfaceCounter).TiltDecenterOrder = 'DxDyDzTxTyTz';
                        else % T->D
                            surfaceObjectArray(surfaceCounter).TiltDecenterOrder = 'TxTyTzDxDyDz';
                        end
                        surfaceObjectArray(surfaceCounter).TiltMode = 'NAX';
                end
            elseif strcmpi(zemaxSurfaceType,'TILTSURF')
                tiltParam = surfaceObjectArray(surfaceCounter).TiltParameter;
                switch n
                    case 1
                        % An angle from x axis => Rotation about y axis
                        tiltParam(2) = atan(value)*180/pi;
                    case 2
                        % An angle from y axis => Rotation about x axis
                        tiltParam(1) = atan(value)*180/pi;
                end
                surfaceObjectArray(surfaceCounter).TiltParameter = tiltParam;
            elseif strcmpi(zemaxSurfaceType,'DGRATING')
                tiltParam = surfaceObjectArray(surfaceCounter).TiltParameter;
                switch n
                    case 1
                        % Lines per um
                        surfaceObjectArray(surfaceCounter).OtherStandardData.GratingLineDensity = value;
                    case 2
                        % DiffractionOrder
                        surfaceObjectArray(surfaceCounter).OtherStandardData.DiffractionOrder = value;
                end
                surfaceObjectArray(surfaceCounter).TiltParameter = tiltParam;
            end
        case 'PPAR'
            % Unknown keyword
            disp(['Surf ',num2str(surfaceCounter),' Warning: PPAR '...
                ' is not known keyword yet.' ]);
        case 'XDAT'
            % Extra data
            disp(['Surf ',num2str(surfaceCounter),' Warning: Extra '...
                ' data is not supported.' ]);
        otherwise
            disp([zmxSurfCommand,' for surface ',num2str(surfaceCounter),...
                'is not included in the zemax importer. ',...
                'Please add the command in the function to import your file properly. '])
            validSurfaceCommand = 0;
    end
    currentLine = readNextLine(inputFile);
    % read the line as space separated string
    currentLineArray = strread(currentLine,'%s');
    % The first element of the array is the 4 character zmx command
    zmxSurfCommand = char(currentLineArray(1,:));
end

nSurf = size(surfaceObjectArray,2);
nonDummySurface = nonDummySurface(1:nSurf);
nonDummySurfaceIndices = find(nonDummySurface);
nextZmxCommand = zmxSurfCommand;
end