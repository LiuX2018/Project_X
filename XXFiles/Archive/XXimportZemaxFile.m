function opticalSystemObject = importZemaxFile (zmxFullFileName)
	% importZemaxFile: imports lens data from .zmx file format generated by zemax. 
	% when unsupported feature is found, display the command in the command window.
	% Input:
	% 	zmxFullFileName: Full file name of .zmx file including its path.
	% Output:
	%	opticalSystemObject: Optical system object


   % <<<<<<<<<<<<<<<<<<<<<<< Algorithm Section>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	% NB: The commnts are based on old version (9.0) of the .zmx file format and
	% shall be corrected with the new format. 

	% <<<<<<<<<<<<<<<<<<<<<<<<< Example Usage>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	%

	% <<<<<<<<<<<<<<<<<<<<<<<<< Author Section >>>>>>>>>>>>>>>>>>>>>>>>>>>>
	%   Written By: Worku, Norman Girma  
	%   Advisor: Prof. Herbert Gross
	%   Part of the RAYTRACE_TOOLBOX V3.0 (OOP Version)
	%	Optical System Design and Simulation Research Group
	%   Institute of Applied Physics
	%   Friedrich-Schiller-University of Jena   
							 
	% <<<<<<<<<<<<<<<<<<< Change History Section >>>>>>>>>>>>>>>>>>>>>>>>>>
	% Date----------Modified By ---------Modification Detail--------Remark
	% Oct 14,2013   Worku, Norman G.     Original Version       Version 3.0

	% <<<<<<<<<<<<<<<<<<<<< Main Code Section >>>>>>>>>>>>>>>>>>>>>>>>>>>>>

	% create an empty optical system object
	mySystem = OpticalSystem;
    nSurf = 0;
    % convert unicode to ascii format running DOS command
    command = ['TYPE "',zmxFullFileName,'">"temAnsiFile"']
    status = dos(command);
    % read the input file
    inputFile = fopen('temAnsiFile', 'r');
      
	% locate the beginning of the file
 	currentPos = ftell(inputFile);

	% read the next valid line
    skippedLine = 0;
	currentLine = readNextLine(inputFile,skippedLine);
    
    while ( ~strcmpi(currentLine,'EOF') )
        % read the line as space separated string
        currentLineArray = strread(currentLine,'%s');

        % The first element of the array is the 4 character zmx command
        zmxCommand = char(currentLineArray(1,:));

        switch zmxCommand
            case 'APLA' % APLA: Curvature aplanatic solve
                disp('Aplanatic surfaces not supported!!');
            case 'CHIA' % CHIA val: Curvature chief ray angle solve value
                disp('Solves surfaces not supported!!');
            case 'CHZH' % CHZH hgt Thickness chief ray height solve.
                disp('Solves surfaces not supported!!');
            case 'CLAP' % CLAP min max Circular aperture min max
                disp('Min Max aperture not supported!!');
            case 'CNOR' % CNOR Curvature chief ray normal.
                disp('Curvature chief ray normal surfaces not supported!!');
            case 'COAT' % COAT The name of the coating used by the surface, if any.
                % read the coating name
                coatName = char(currentLineArray(2,:));
                % import coating object 
                disp('Coating import not supported!!');
            case 'COMM' % COMM Comment for the current surface.
                % comment starts from 5th place 
                mySystem.SurfaceArray(surfIndex+1).Comment = currentLine(5:length(currentLine));

            case 'CONI' % CONI val Conic constant
                % the second element is conic constant of current surface
                k = str2num(char(currentLineArray(2,:)));
                mySystem.SurfaceArray(surfIndex+1).Conic = k;
                % set surface type 
                if k ~= 0
                    mySystem.SurfaceArray(surfIndex+1).Type = 'Conic Aspherical';
                end


            case 'CURV' % CURV val solvetype param1 param2 The curvature value of a surface. 
                        % The solvetype is an integer code that indicates the type of solve, 
                        % and the two following parameters are the solve parameters.
                radius = 1/(str2num(char(currentLineArray(2,:))));
                mySystem.SurfaceArray(surfIndex+1).Radius = radius;
%                 if abs(radius) < 10^10
%                     % set the semidiameter and apperture value from the radius
%                     mySystem.SurfaceArray(surfIndex+1).ApertureType = 'Circular';
%                     mySystem.SurfaceArray(surfIndex+1).ApertureParameter(1) = abs(radius - 0.05*radius);
%                     mySystem.SurfaceArray(surfIndex+1).SemiDiameter =  abs(radius - 0.05*radius);
%                 else
                    % set the semidiameter and apperture value to fixed
                    % value 1
%                     mySystem.SurfaceArray(surfIndex+1).ApertureType = 'Circular';
%                     mySystem.SurfaceArray(surfIndex+1).ApertureParameter(1) = 1;
%                     mySystem.SurfaceArray(surfIndex+1).SemiDiameter = 1;                    
%                end

                % set surface type 
                if radius < 10^10
                    mySystem.SurfaceArray(surfIndex+1).Type = 'Spherical';
                end

                % ignore solve for current version
                disp('Solves not supported!!');
            case 'DIAM' % DIAM val solvecode pusurf The semi-diameter of a surface. 
                        % The solvecode is 0 for automatic, 1 for fixed, 2 for pickup 
                        % and 3 for maximum. The pusurf value is only required for solvecode = 2.
                semiDiam = (str2num(char(currentLineArray(2,:))));
                if isnan(semiDiam)
                    mySystem.SurfaceArray(surfIndex+1).ApertureType = 'Circular';
                    mySystem.SurfaceArray(surfIndex+1).ApertureParameter(1) = 1;
                    mySystem.SurfaceArray(surfIndex+1).SemiDiameter = 1; 
                else
                    mySystem.SurfaceArray(surfIndex+1).ApertureType = 'Circular';
                    mySystem.SurfaceArray(surfIndex+1).ApertureParameter(1) = semiDiam;
                    mySystem.SurfaceArray(surfIndex+1).SemiDiameter = semiDiam;
                end
                % ignore solve for current version		
                disp('Solves not supported!!');
            case 'DISZ' % DISZ val The Z thickness of a surface
                if strcmpi(char(currentLineArray(2,:)),'INFINITY')
                    mySystem.SurfaceArray(surfIndex+1).Thickness = Inf;
                else
                    mySystem.SurfaceArray(surfIndex+1).Thickness = (str2num(char(currentLineArray(2,:))));
                end
            case 'EDGE' % EDGE thi rad Thickness edge thickness solve.
                disp('Edge thickness not supported!!');
            case 'ELAP' % ELAP xwid ywid Elliptical aperture.
                disp('Ellipse aperture not supported!!');
            case 'ELOB' % ELOB xwid ywid Elliptical obscuration.
                disp('Ellipse aperture not supported!!');
            case 'ENPD' % ENPD val Entrance pupil diameter value.
                mySystem.SystemApertureType = 1;
                mySystem.SystemApertureValue = (str2num(char(currentLineArray(2,:))));
            case 'ENVD' % ENVD temp pres Environment data. The temp and pres values are in
                        % degrees c and atmospheres, respectively.
                disp('Environment data is not supported!!');		
            case 'FLAP' % FLAP Floating aperture.
                disp('Floating aperture is not supported!!');
            case 'FLOA' % FLOA val Float by stop size. The val argument is ignored
                disp('Floating by stop size is not supported!!');
            case 'FNUM' % FNUM val Image space F/# value 
                disp('Image space F/# value is not supported!!');
            case 'FTYP' % FTYP i Field type. The integer i is 0, 1, or 2 for field angle,
                    % object height, or image height
                mySystem.FieldType = (str2num(char(currentLineArray(2,:)))+1);
                if str2num(char(currentLineArray(2,:)))==2
                    disp('Image height field value is not supported!!');
                end
            case 'FWGT' % FWGT val1 val2 val3... The field weights. See XFLD	
                ss = size(currentLineArray);
                nFieldPoint = ss(1)-1; % number of field points defined
                mySystem.NumberOfFieldPoints = nFieldPoint;
                mySystem.FieldPointMatrix(:,1)= str2num((currentLineArray(2:ss(1)))');

                % record  weight of each field points
                %for kk = 1:1:nFields
                %	mySystem.FieldPointMatrix(kk,3) = (str2num(currentLineArray(kk+1));
                %end
            case 'GARR' % GARR i sag dx dy dxdy Used for defining the grid surface data. "i" is the array
                    % index, starting at 0. The other values are the sag, the
                    % derivative of the sag in the x direction, the derivative
                    % of the sag in the y direction, and the second cross
                    % derivative. Must follow after the GDAT command
                disp('Grid surface is not supported!!');
            case 'GCAT' % GCAT name1 name2 name3 ... Indicates which glass catalogs are used by the lens.
                ss = size(currentLineArray);
                nGlassCat = ss(1)-1; % number of glass catalogues used
                if nGlassCat > 1||~strcmpi(char(currentLineArray(2,:)),'Schott')
                    disp('Catalogues other than Schott are not supported!!');
                else

                end
            case 'GDAT' % GDAT ix iy dx dy Defines the grid data header for the surface. The
                    % values are the number of x and y pixels, and the delta
                    % x increment and delta y increment
                disp('Image height field value is not supported!!');
            case 'GFAC' % GFAC val type Apodization factor value and type. The type code is 0
                    % for none, 1 for Gaussian, and 2 for tangential.
                disp('GFAC is not supported!!');
            case 'GLAS' % GLAS name code pu nd vd pd vnd vvd vpd io ao The glass of the surface. 
                    % Name is the glass name,such as BK7. Code is 0 for fixed, 1 for model, 
                    % 2 for pickup. Pu is the pickup surface, which must be supplied even if the 
                    % solve is not a pickup. nd, vd, and pd are the index, abbe, and partial dispersion 
                    % values, which are only used if the glass is a model. The vnd,vvd, and vpd codes 
                    % are 0 if that parameter is variable, else they are unity. The io and ao values are 
                    % the index and Abbe offsets respectively, which are used primarily for tolerancing. 
                    % A glass name must be supplied, even if the glass is a model glass
                    % extract the schott glass from glass catalogue of the system

                    glassName = char(currentLineArray(2,:));
                    load('f:\aoe_schott_optical_glass_catalogue_excel_april_2013.xls.mat','AllGlass');

                    location = find(strcmpi({AllGlass.Name},glassName));
                    if ~isempty(location)
                      % File exists.  Do stuff....
                        mySystem.SurfaceArray(surfIndex+1).Glass = AllGlass(location);
                    else
                      % File does not exist.
                      msgbox ([glassName,' : The glass file does not exsist in the catalogue. So it is set to default 1.5 glass']);
                      glasName = 'FixedIndexGlass';
                      sellCoeff = [1.5 0 0 0 0 0];                      
                      mySystem.SurfaceArray(surfIndex+1).Glass = Glass(glasName,sellCoeff); 
                    end            

            case 'GLRS' % GLRS surf Global coordinate reference surface.
                disp('GFAC is not supported!!');
            case 'HIDE' % HIDE Hide rays to/from surface flag.
                disp('GFAC is not supported!!');
            case 'MARA' % MARA val Curvature marginal ray angle solve value.
                disp('GFAC is not supported!!');
            case 'MAZH' % MAZH hgt zone Thickness marginal ray height solve.
                disp('GFAC is not supported!!');
            case 'MNOR' % MNOR Curvature marginal ray normal.
                disp('GFAC is not supported!!');
            case 'MNUM' % MNUM n Number of configurations.
                disp('GFAC is not supported!!');
            case 'NAME' % NAME string... Indicates the "lens name" description.
                mySystem.LensName = currentLine(5:length(currentLine));
            case 'NOTE' % NOTE i string Lens notes. "i" should be between 1 and 3, inclusive,
                    % and the string can be any text.
                mySystem.LensNote = currentLine(5:length(currentLine));
            case 'OBDC' % OBDC xdec ydec Obscuration and aperture decenter x and decenter y.
                disp('OBDC is not supported!!');
            case 'OBNA' % OBNA val Object space numerical aperture value.
                mySystem.SystemApertureType = 2;
                mySystem.SystemApertureValue = (str2num(char(currentLineArray(2,:))));
            case 'OBSC' % OBSC min max Circular obscuration min max.
                disp('OBSC is not supported!!');
            case 'OPDZ' % OPDZ opd zone Thickness OPD solve.
                disp('OPDZ is not supported!!');
            case 'PARM' % PARM n val Parameter n is the value of "val".
                disp('PARM is not supported!!');
            case 'PCUP' % PCUP n val Curvature pickup solve from surface n times val
                disp('PCUP is not supported!!');
            case 'PICB' % PICB i Paraxial Ignore Coordinate Breaks, i = 0 is false, i = 1
                    % is true. Default is true.
                disp('PICB is not supported!!');
            case 'PKUP' % PKUP n val Conic pickup from surface n times val.
                disp('PKUP is not supported!!');
            case 'POLS' % POLS nUnpol Ex Ey Phax Phay Default polarization state data.
                disp('POLS is not supported!!');
            case 'PPAR' % PPAR i n val Parameter i pickup from n times val.
                disp('PPAR is not supported!!');
            case 'PUSH' % PUSH val Pupil Shift. Used only if ray aiming is on. The "val" is
                    % in lens units.
                disp('PUSH is not supported!!');
            case 'PWAV' % PWAV n The primary wavelength indicator.
                mySystem.PrimaryWavelengthIndex = str2num(char(currentLineArray(2,:)));
            case 'PZUP' % PZUP n val Thickness pickup from n times val.
                disp('PZUP is not supported!!');
            case 'RADI' % RADI val The radius of curvature. Now obsolete, use CURV.
                disp('RADI is not supported!!');
            case 'RAIM' % RAIM tol type fastasphere usecache grinaper robust The ray aiming and a 
                    % few other settings on the advanced box are controlled by this command. 
                    % Tol is no longer used, but some value (such as zero) must be present as a 
                    % placeholder. Type is 0, 1, or 2 for None, Paraxial, or Real ray aiming. 
                    % Fastasphere is 1 if the "Fast Asphere Trace" is selected, otherwise it is 0. 
                    % Usecache is 1 if "Use Ray Aiming Cache" is selected, otherwise it is 0. 
                    % Grinaper is 1 if "Check Grin Aper" is selected, otherwise it is 0. 
                    % Robust is 1 if "Robust Ray Aiming" is selected, otherwise it is 0.
                disp('RAIM is not supported!!');
            case 'ROPD' % ROPD i Reference OPD setting. For i = 0, 1, and 2, the
                    % reference point is Absolute, Infinity, and Exit Pupil,
                    % respectively. Use Exit Pupil as the default.
                disp('ROPD is not supported!!');
            case 'SDMA' % SDMA margin fast_semi_diameters Semi-diameter margin, and fast semi-diameter mode flag.
                disp('ROPD is not supported!!');
            case 'SLAB' % SLAB int Surface label. This is a unique integer ZEMAX
                    % assigns to each surface to identify the surface as new
                    % surfaces are inserted or old ones deleted. Some
                    % features that depend upon knowing where a surface
                    % has moved to in the list of surfaces use this label to
                    % keep track of the renumbered surfaces.

            case 'SPID' % SPID numarms width Spider aperture.
                disp('SPID is not supported!!');
            case 'SQAP' % SQAP xwid ywid Rectangular aperture.
                disp('SQAP is not supported!!');
            case 'SQOB' % SQOB xwid ywid Rectangular obscuration.
                disp('SQOB is not supported!!');

            case 'STOP' % STOP Indicates the current surface is the stop surface.
                mySystem.SurfaceArray(surfIndex+1).Stop = 1;
            case 'SURF' % SURF Increments the surface counter.
                surfIndex = str2num(char(currentLineArray(2,:)));
                nSurf = nSurf + 1;          
                
            case 'TCED' % TCED val v TCE value of surface. v is unity if variable, else 0.
                disp('TCED is not supported!!');
            case 'TCOC' % TCOC surf Thickness center of curvature solve.
                disp('TCOC is not supported!!');
            case 'TCOM' % TCOM surf thickness Thickness compensator solve.
                disp('TCOM is not supported!!');
            case 'TOLE' % TOLE n length Thickness position solve.
                disp('TOLE is not supported!!');
            case 'TYPE' % TYPE codename Indicates the current surface type. The codenames
                    % are listed in a following section.
                % switch char(currentLineArray(2,:))
                    % case 'STANDARD'			
                    % otherwise

                % end
                % For now make the surface type Plane and then change to spherical if rad~=inf,
                % and then to aspheric if conic constant is ~= 0
                mySystem.SurfaceArray(surfIndex+1).Type = 'Plane';
            case 'UDAD' % UDAD x y User defined aperture data x and y.
                disp('UDAD is not supported!!');
            case '' % UNIT code Specifies the lens units. The "code" must be either
                    % MM, CM, IN, or METER.

            case 'USAP' % USAP min max User defined aperture min max.
                disp('USAP is not supported!!');
            case 'USOB' % USOB min max User defined obscuration min max.
                disp('USOB is not supported!!');
            case 'VCON' % VCON Conic is variable.
                disp('VCON is not supported!!');
            case 'VCUR' % VCUR Curvature is variable.
                disp('VCUR is not supported!!');
            case 'VDSZ' % VDSZ Thickness is variable.
                disp('VDSZ is not supported!!');
            case 'VERS' % VERS n The version number of ZEMAX that created the file.
                disp('VERS is not supported!!');
            case 'VPAR' % VPAR n Parameter n is variable
                disp('VPAR is not supported!!');
            case 'WAVL' % WAVL val1 val2 val3... The wavelength values in microns.
                ss = size(currentLineArray);
                nWavelength = ss(1)-1; % number of wavelengths defined
                mySystem.NumberOfWavelengths = nWavelength;
                mySystem.WavelengthMatrix(:,1)= str2num((currentLineArray(2:ss(1)))');
            case 'WWGT' % WWGT val1 val2 val3... The wavelength weights.
                ss = size(currentLineArray);
                nWavelength = ss(1)-1; % number of wavelengths defined
                mySystem.NumberOfWavelengths = nWavelength;
                mySystem.WavelengthMatrix(:,2)= str2num((currentLineArray(2:ss(1)))');
            case 'XDAT' % XDAT n val v pus sca Extra Data Parameter n has value val. If v is unity, then
                    % the value is variable. If v is 2, then there is a pickup
                    % solve on the extra data parameter. The pickup surface
                    % number is pus and the scale factor is sca.
                disp('XDAT is not supported!!');
            case 'XFLD' % XFLD val1 val2 val3... The x-field values. There are from 1 to 12 values
                    % separated by spaces. The units depend upon the field
                    % type, either degrees or lens units.
                ss = size(currentLineArray);
                nFieldPoint = ss(1)-1; % number of field points defined
                mySystem.NumberOfFieldPoints = nFieldPoint;
                mySystem.FieldPointMatrix(:,1)= str2num((currentLineArray(2:ss(1)))');
            case 'YFLD' % YFLD val1 val2 val3... The y-field values. See XFLD.
                ss = size(currentLineArray);
                nFieldPoint = ss(1)-1; % number of field points defined
                mySystem.NumberOfFieldPoints = nFieldPoint;
                mySystem.FieldPointMatrix(:,2)= str2num((currentLineArray(2:ss(1)))');		
            case 'ZVCX' % ZVCX val1 val2 val3... The VCX vignetting factors.
                disp('ZVCX is not supported!!');
            case 'ZVCY' % ZVCY val1 val2 val3... The VCY vignetting factors.
                disp('ZVCY is not supported!!');
            case 'ZVDX' % ZVDX val1 val2 val3... The VDX vignetting factors.
                disp('ZVDX is not supported!!');
            case 'ZVDY' % ZVDY val1 val2 val3... The VDY vignetting factors.
                disp('ZVDY is not supported!!');
            otherwise
                disp([zmxCommand,' : UNKNOWN command found!!']);
        end
                
       % read the next valid line
%        currentPos = ftell(inputFile);
%        fseek(inputFile,1,currentPos);
       skippedLine = 0;
	   currentLine = readNextLine(inputFile,skippedLine);
    end
    mySystem.NumberOfSurface =  nSurf;
    mySystem.SurfaceArray(1).ObjectSurface = 1;
    mySystem.SurfaceArray(nSurf).ImageSurface = 1;
    
    opticalSystemObject = mySystem; 
end
%%%%%%%%%%%%%%%%%%%%%%%
function nextLine =  readNextLine(inputFile,skippedLine)
    line = (fgets(inputFile));
    if length(line)< 4 && skippedLine < 5
        % invalid line just skip
        skippedLine = skippedLine + 1;
        nextLine =  readNextLine(inputFile,skippedLine);
        
    end

    if ischar(line) && skippedLine < 5
        nxtL = strtrim(line);
        % nxtL(2:2:length(nxtL)) = '';
    else
        nxtL = 'EOF';
    end
    
	nextLine = nxtL;
    
end
%%%%%%%%%%%%%%%%%%%%%%%