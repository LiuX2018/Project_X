function opticalSystem = importZMX (lensCatalogueFullFileName,zmxFullFileName)
	% importZemaxFile: imports lens data from .zmx file format generated by zemax. 
	% when unsupported feature is found, display the command in the command window.
	% Input:
	% 	zmxFullFileName: Full file name of .zmx file including its path.
	% Output:
	%	opticalSystemObject: Optical system object

	% <<<<<<<<<<<<<<<<<<<<<<<<< Author Section >>>>>>>>>>>>>>>>>>>>>>>>>>>>
	%   Written By: Worku, Norman Girma  
	%   Advisor: Prof. Herbert Gross
	%	Optical System Design Research Group
	%   Institute of Applied Physics
	%   Friedrich-Schiller-University of Jena   
							 
	% <<<<<<<<<<<<<<<<<<< Change History Section >>>>>>>>>>>>>>>>>>>>>>>>>>
	% Date----------Modified By ---------Modification Detail--------Remark
	% July 28,2014   Worku, Norman G.     Original Version        

	% <<<<<<<<<<<<<<<<<<<<< Main Code Section >>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    % Get the file name and path name of the ZMX file
    if nargin == 0
        [FileName,PathName] = uigetfile('*.zmx','Select ZMX File');
        if ~isempty(FileName)&&~isempty(PathName) && ...
            ~isnumeric(FileName) && ~isnumeric(PathName)
            zmxFullFileName = [PathName,FileName];
        else
            opticalSystem = 0;
            return;
        end

        lensCatalogueFullFileName = createLensCatalogue;
        disp(['Warning: You have not given an existing lens catalogue. '...
              'So your lens will be saved in a newly created lens ',...
              'calalogue:']);
        disp(lensCatalogueFullFileName);
        
    elseif nargin == 1  
        [FileName,PathName] = uigetfile('*.zmx','Select ZMX File');
        if ~isempty(FileName)&&~isempty(PathName) && ...
            ~isnumeric(FileName) && ~isnumeric(PathName)
            zmxFullFileName = [PathName,FileName];
        else
            opticalSystem = 0;
            return;
        end        
    end    
    
    [PathName,name,ext] = fileparts(zmxFullFileName);
    FileName = [name,ext];
    
	% create an empty optical system struct
    newLens = orderfields(struct...
            ('FileName',{},'NumberOfSurfaces',{},'SurfaceArray',{},...
            'SystemApertureType',{},'EntrancePupilDiameter',{},...
            'ObjectSpaceNA',{}, 'ObjectConeAngle',{},...
            'WorkingFNumber',{},'ImageSpaceFNumber',{},...
            'EnvironmentalData',{},'FieldType',{},...
            'NumberOfFieldPoints',{},'FieldNormalization',{},...
            'FieldPointMatrix',{},'AfocalImageSpace',{},...
            'TelecentricObjectSpace',{},'IterateSolves',{},...
            'NumberOfWavelengths',{},'WavelengthMatrix',{},...
            'PrimaryWavelengthIndex',{},'GlassCatalogues',{},...
            'ApodizationType',{},'ApodizationFactor',{},...
            'GlobalReference',{},'FNumberComputation',{},...
            'Mode',{},'LensName',{},'LensNote',{},...
            'ParaxialIgnoreCB',{},'ReferenceOPD',{},...
            'LensUnit',{},'WavelengthUnit',{},...
            'SoftwareVersion',{}));
  
    surfCounter = 0;
    nSurf = 0;
    % convert unicode to ascii format running DOS command
    command = ['TYPE "',zmxFullFileName,'">"temAnsiFile"'];
    status = dos(command);
    % read the input file
    inputFile = fopen('temAnsiFile', 'r');
      
	% locate the beginning of the file
 	currentPos = ftell(inputFile);

	% read the next valid line
    skipNextLineRead = 0;
	currentLine = readNextLine(inputFile);
    disp('Started: Importing system configuration data...');    
    while ( ~strcmpi(currentLine,'EOF') )
        % read the line as space separated string
        currentLineArray = strread(currentLine,'%s');

        % The first element of the array is the 4 character zmx command
        zmxCommand = char(currentLineArray(1,:));

        switch zmxCommand
            case 'ENPD'
            % ENPD val	: Entrance Pupil Diameter Value
                newLens(1).SystemApertureType = 'EntrancePupilDiameter';
                newLens(1).EntrancePupilDiameter = (str2num(char(currentLineArray(2,:))));            
            case 'ENVD'
            % ENVD temp pres on	: Environment data. The temp and pres values 
            % are in degrees c and atmospheres, respectively. 
            % On = 0 or 1: Indicate whether to adjust index to environment data (1) or not (0).
                temp = str2num(char(currentLineArray(2,:)));
                pres = str2num(char(currentLineArray(3,:)));
                on = str2num(char(currentLineArray(4,:)));
                newLens(1).EnvironmentalData = [temp,pres,on];  		        
            case 'FLOA'
            % FLOA val	: Float by stop size. val is just ignored
                newLens(1).SystemApertureType = 'FLOA';                
            case 'FNUM'
            % FNUM  val I	I = 0:Image Space F/# Value I = 1:Paraxial Working F/#
                val = str2num(char(currentLineArray(2,:)));
                I = str2num(char(currentLineArray(3,:)));
                if I == 0
                    newLens(1).SystemApertureType = 'ImageSpaceFNumber';
                    newLens(1).ImageSpaceFNumber = val; 
                else
                    newLens(1).SystemApertureType = 'WorkingFNumber';
                    newLens(1).WorkingFNumber = val; 
                end
                          
            case 'FTYP'
            % FTYP type objTelecentric nfieldpts nWavelength fieldnorm 
            %           iterateSolves afocalImageSpace	: Field Type.
            % Type = 0,1,2,3 for Angle, Object Height, Paraxial Image Height, 
            %        and Real Image Height respectively.
            % objTelecentric: Telecentric object space
            % Nfieldpts: number of field points selected.
            % nWavelength : number of wavelengths selected.
            % Fieldnorm: 0,1 for Radial and Rectangular field normalization.
            % iterateSolves: Iterate solves when updating.
            % afocalImageSpace: Afocal image space.

                ftype = str2num(char(currentLineArray(2,:)));
                objTelecentric = str2num(char(currentLineArray(3,:)));
                nfieldpts = str2num(char(currentLineArray(4,:)));
                nwavelengths = str2num(char(currentLineArray(5,:)));
                fnorm = str2num(char(currentLineArray(6,:)));
                iterateSolves = str2num(char(currentLineArray(7,:)));
                afocalImageSpace = str2num(char(currentLineArray(8,:)));
                
                if ftype == 0
                    newLens(1).FieldType = 'Angle';
                elseif ftype == 1
                    newLens(1).FieldType = 'ObjectHeight';
                elseif ftype == 2
                    newLens(1).FieldType = 'ParaxialImageHeight';
                else
                    newLens(1).FieldType = 'RealImageHeight';
                end

                
                newLens(1).NumberOfFieldPoints = nfieldpts;
                newLens(1).FieldPointMatrix = repmat([0,0,1],[nfieldpts,1]);
                
                
                newLens(1).NumberOfWavelengths = nwavelengths;
                newLens(1).WavelengthMatrix = repmat([0,1],[nwavelengths,1]);
                
                
                if fnorm == 0
                    newLens(1).FieldNormalization = 'Radial';
                else
                    newLens(1).FieldNormalization = 'Rectangular';
                end   
                
                newLens(1).AfocalImageSpace = afocalImageSpace;
                newLens(1).TelecentricObjectSpace = objTelecentric;
                newLens(1).IterateSolves = iterateSolves;
            case 'XFLN'
            % XFLN val1 val2 val3...	The x field values (total 12)
                % number of field points defined    
                nFieldPoint = newLens(1).NumberOfFieldPoints;
                newLens(1).FieldPointMatrix(:,1)= str2num(char((currentLineArray(2:nFieldPoint+1))));            
            case 'YFLN'
            % YFLN val1 val2 val3...	The y field values (total 12)
                % number of field points defined    
                nFieldPoint = newLens(1).NumberOfFieldPoints;
                newLens(1).FieldPointMatrix(:,2)= str2num(char((currentLineArray(2:nFieldPoint+1))));
            case 'FWGN'
            % FWGN val1 val2 val3...	Field weights (total 12)
                % number of field points defined    
                nFieldPoint = newLens(1).NumberOfFieldPoints;
                newLens(1).FieldPointMatrix(:,3)= str2num(char((currentLineArray(2:nFieldPoint+1))));
            
            case 'GCAT'
            % GCAT name1 name2 name3 ...	Indicates which glass catalogs are used by the lens.
                newLens(1).GlassCatalogues = currentLineArray(2:end);                                     
            case 'GFAC'
            % GFAC val type	:Apodization factor value and type. The type code is 0
            % for none, 1 for Gaussian, and 2 for cosine cubed.
                apodVal = str2num(char(currentLineArray(2,:)));
                apodType = str2num(char(currentLineArray(3,:)));
                if apodType == 0
                    newLens(1).ApodizationType = 'None';
                elseif apodType == 1
                    newLens(1).ApodizationType = 'Gaussian';               
                else
                    newLens(1).ApodizationType = 'CosineCubed';
                end
                newLens(1).ApodizationFactor = apodVal;
            case 'GLRS'
            % GLRS surf f#comp	:Global Surface
            % Surf: index of global surface.
            % f#comp: 0,1 if method to compute F/# = “tracing rays” and “pupil size/position” respectively.  
                surf = str2num(char(currentLineArray(2,:)));
                fcomp = str2num(char(currentLineArray(3,:)));  
                newLens(1).GlobalReference = surf;
                if fcomp == 0
                    newLens(1).FNumberComputation = 'RayTracing';
                else
                    newLens(1).FNumberComputation = 'Pupil';
                end
        
            case 'MODE'
            % MODE SEQ	SEQ =  Sequential Mode or Hybrid
            % NSQ =  Non-sequential Mode
                mode = char(currentLineArray(2,:));
                newLens(1).Mode =  mode;
            case 'NAME'
            % NAME name	: Name of the lens
            if size(currentLineArray,2) == 2
                newLens(1).LensName = char(currentLineArray(2,:));
            else
                newLens(1).LensName = 'Untitled';
            end
            case 'NOTE'
            % NOTE I Notes...	Notes related to the lens
            % I = {0, 4} ??
            if size(currentLineArray,1) == 3
                newLens(1).LensNote = char(currentLineArray(3,:));
            else
                newLens(1).LensNote = 'No Note';
            end
            case 'NSCD'
            % NSCD maxInter maxSeg minAbsInt minRelInt maxObj glueDist 
            % retrace ??0 ??0 ??0 misdRayDrawDist ??1 maxSrcRay simpRaySplit 
            % ??2	: Non-sequential data
            % maxInter:maximum intersection per ray
            % maxSeg: maximum segments per ray
            % minAbsInt: minimum absolute ray intensity
            % minRelInt: minimum relative ray intensity
            % maxObj: maximum nested/touching objects
            % glueDist: glue distance in lens units
            % retrace: 1 if “Retrace source rays upon file open” is selected and 0 otherwise
            % ??0 ??0 ??0 
            % misdRayDrawDist: missed ray draw distance in lens units
            % ??1 
            % maxSrcRay: maximum source file rays in memory
            % simpRaySplit: 1 if “Simple ray splitting” is selected and 0 otherwise
            % ??2
               disp('Warning: All non sequential data are ignored.');
            case 'OBNA'
            % OBNA val I	I = 0:Object Space NA and I = 1: object cone angle
                value = str2num(char(currentLineArray(2,:)));
                I = str2num(char(currentLineArray(3,:)));
                if I == 0
                    newLens(1).SystemApertureType = 'ObjectSpaceNA';
                    newLens(1).ObjectSpaceNA = value;
                else
                    newLens(1).SystemApertureType = 'ObjectConeAngle';
                    newLens(1).ObjectConeAngle = value;
                end
                    
            case 'PICB'
            % PICB i	: Paraxial Ignore Coordinate Breaks, 
            % i = 0 is false, i = 1 is true. Default is true.
                I = str2num(char(currentLineArray(2,:)));
                newLens(1).ParaxialIgnoreCB = I;
            case 'POLS'
            % POLS unpol Ex Ey Phax Phay thinfilmtorayconvert refMethod :	Dafault polarization state used.
            % Unpol is 1 if “Unpolarized” is selected otherwise it is 0.
            % Thinfilmtorayconvert is 1 if “Convert thin film phase to ray equivalent” is selected otherwise it is 0.
            % refMethod is 0,1,2 for X-, Y- and Z-Axis reference method.
                unpol = str2num(char(currentLineArray(2,:)));
                Ex = str2num(char(currentLineArray(3,:)));
                Ey = str2num(char(currentLineArray(4,:)));
                Phax = str2num(char(currentLineArray(5,:)));
                Phay = str2num(char(currentLineArray(6,:)));
                thinfilmtorayconvert = str2num(char(currentLineArray(7,:)));
                refMethod = str2num(char(currentLineArray(8,:)));
                disp(['Warning: Default polarization state is just ignored for now.']);
            case 'PUSH'
            % PUSH pupilshiftz pupilshifty pupilshiftx scalepupilshift pupilcompressx pupilcompressy	Pupil shift. All values indicate the corresponding values in the General system window.
            % Scalepupilshift is 1 if “Scale Pupil Shift factors by field” is selected else it is 0.
                disp(['Warning: Pupil Shift (PUSH) is not supported.']);
            case 'RAIM'
            % RAIM tol type ?? fastasphere usecache grinaper robust 
            % threadingoff dontprintcoordbreak opd2modpi	: The ray aiming and a few other settings.
            % Fastasphere is 1
            % if the "Fast Asphere Trace" is selected, otherwise it is
            % 0.
            % Threadingoff is 1 if “Turn Off Threading” is selected, otherwise 0.
            % Grinaper is 1 if "Check Grin
            % Aper" is selected, otherwise it is 0.
            % Dontprintcoordbreak is 1 if “Don’t Print Coordinate Break Data” is selected, otherwise 0.
            % Tol is
            % no longer used, but some value (such as zero) must
            % be present as a placeholder. 
            % Type is 0, 1, or 2 for
            % None, Paraxial, or Real ray aiming.
            % opd2modpi is 1 if “OPD Modulo 2 pi” is selected, otherwise 0.
            % 
            % Usecache is 1 if "Use Ray Aiming Cache" is
            % selected, otherwise it is 0. 
            % Robust is 1 if
            % "Robust Ray Aiming" is selected, otherwise it is 0.
                disp(['Warning: Ray aim (RAIM) is just ignored for now.']);
            case 'ROPD'
            % ROPD i	Reference OPD setting. For i = 0, 1, 2, and 3, the
            % reference point is Absolute, Infinity,Exit Pupil, and Absolute 2 respectively. Use Exit Pupil as the default.
                disp(['Warning: The reference OPD setting is ignored. ',...
                    'It is usually at Exit pupil.']);
                I = str2num(char(currentLineArray(2,:)));
                if I == 0
                    newLens(1).ReferenceOPD = 'Absolute';
                elseif I == 1
                    newLens(1).ReferenceOPD = 'Infinity';
                elseif I == 2
                    newLens(1).ReferenceOPD = 'ExitPupil';
                else
                    newLens(1).ReferenceOPD = 'Absolute2';
                end
                
            case 'SCAT'
            % SCAT model fraction angle ??“”	Scattering
            % Model: Scattering model. 0(No Scattering),1(Lamberitian),2(Gaussian),3(ABg),4(ABg file),5(BSDF),6(IS Scatter Catalogue),7(User Defined)
            % Fraction: Scatter fraction
            % Angle: Angle
            % ??“”
                disp(['Warning: Scaterring data (SCAT) is just ignored for now.']);
            case 'UNIT'
            % UNIT LensUnit SourceUnitPrefix SourceUnit 
            % AnalysisUnitPrefix AnalysisUnit AfocalModeUnit 
            % MTFUnit	
            % LensUnit {MM,CM,IN,METER}
            % SourceUnitPrefix {F,P,N,U,M,X,K,E,G,T}
            % SourceUnit{W,L,J}
            % AnalysisUnitPrefix{F,P,N,M,G}
            % AnalysisUnit{MM,CM,IN,ME,FT}
            % AfocalModeUnit{UR,MR,RR,AS,AM,DG}
            % MTFUnit{CPMM,CPMR}
            % 
                LENSUNIT = char(currentLineArray(2,:));
                % Wavelength is always in microns in ZMX                
                newLens(1).WavelengthUnit = 'UM';
                newLens(1).LensUnit = LENSUNIT;
                
            case {'VANN','VCXN','VCYN','VDXN','VDYN'}
            % VANN val1 val2 val3...	VAN vignating factors (total 12)
                disp('Warning: Vignating factors are just ignored for now.'); 
            case 'VERS'  
                % VERS 130724 1 23203 The version of Zemax file used to create the .zmx file.
                version = char(currentLineArray(2:end,:));
                newLens(1).SoftwareVersion = version;
                
            case 'WAVM'
            % WAVM N wavlen weight	: Wavelength
            % N = 1,2,…24 indicating the wavelength index
            % Wavlen: the waveleght value
            % Weight: corresponding weight
                nwav = newLens(1).NumberOfWavelengths;
                N = str2num(char(currentLineArray(2,:)));
                wavlen = str2num(char(currentLineArray(3,:)));
                weight = str2num(char(currentLineArray(4,:)));
                if N <= nwav
                    newLens(1).WavelengthMatrix(N,1) = wavlen;
                    newLens(1).WavelengthMatrix(N,2) = weight;
                end
            case 'PWAV'
            % PWAV ind	: Primary wavelength index (starts from 1).
                newLens(1).PrimaryWavelengthIndex = str2num(char(currentLineArray(2,:)));            
            case 'SURF'
            % SURF index	Surface index starting from 0 @ object surface.
                disp('Completed: Importing system configuration data.');
                disp(' ');
                disp('Started: Importing surface data...');
                [surfArray,nextZmxCommand] = readSurfaceArray(inputFile);
                newLens(1).SurfaceArray = surfArray; 
                % Skip readLine for the next command as it is already read
                % by the readSurfaceArray function
                skipNextLineRead = 1;
                disp('Completed: Importing surface data.');
                disp(' ');
            case 'MFDS'
                disp('Started: Importing Merit function data...');
                [meritFunction,nextZmxCommand] = readMeritFunction(inputFile);
                % Skip readLine for the next command as it is already read
                % by the readMeritFunction function
                skipNextLineRead = 1;
                disp('Completed: Importing Merit function data.');
                disp(' ');
            case 'MNUM'
            % MNUM n ??1	Number of configuration
                disp('Started: Importing Multi-configuration data...');
                [multiConfigData,nextZmxCommand] = readMultiConfigurationData(inputFile);
                % Skip readLine for the next command as it is already read
                % by the readMultiConfigurationData function
                skipNextLineRead = 1;  
                disp('Completed: Importing Multi-configuration data.');
                disp(' ');
            case 'TOL'
                disp('Started: Importing Tolerance data...');
                [toleranceData,nextZmxCommand] = readToleranceData(inputFile);
                % Skip readLine for the next command as it is already read
                % by the readToleranceData function
                skipNextLineRead = 1; 
                disp('Completed: Importing Tolerance data.');
                disp(' ');
        end                
       % read the next valid line      
       if skipNextLineRead
           currentLine = nextZmxCommand;
           skipNextLineRead = 0;
       else
           currentLine = readNextLine(inputFile);
       end
    end
    nSurf = size(newLens(1).SurfaceArray,2);
    newLens(1).NumberOfSurfaces =  nSurf;
    newLens(1).SurfaceArray(1).ObjectSurface = 1;
    newLens(1).SurfaceArray(nSurf).ImageSurface = 1;
    newLens(1).FileName = FileName;
    
    opticalSystem = newLens(1); 
    addLensToLensCatalogue(newLens(1),lensCatalogueFullFileName);
end

%%%%%%%%%%%%%%%%%%%%%%%
function nextLine =  readNextLine(inputFile)
    line = (fgets(inputFile));
    if ischar(line)
        nxtL = strtrim(line);
        % nxtL(2:2:length(nxtL)) = '';
        if length(line)< 3
            % invalid line just skip
            disp('Error: Invalid zmx command line found.');
            nextLine =  readNextLine(inputFile);        
        end
    else
        nxtL = 'EOF';
    end
    
	nextLine = nxtL;
    
end

%%%%%%%%%%%%%%%%%%%%%%%
function [meritFunction,nextZmxCommand] = readMeritFunction(inputFile)
disp('Currently merit functions can not be imported. So all are just ignored');
% Ignore all lines of text, until we see one that just consists of this:
% {'MNUM','TOL','CSUM'}
while 1
    currentLine = readNextLine(inputFile);
    % read the line as space separated string
    currentLineArray = strread(currentLine,'%s');
    % The first element of the array is the 4 character zmx command
    zmxSurfCommand = char(currentLineArray(1,:));

    % Break if we hit end of file, or the start marker
    if ~ischar(currentLine)  ||  strcmp(zmxSurfCommand, 'MNUM')...
    ||  strcmp(zmxSurfCommand, 'TOL') ||strcmp(zmxSurfCommand, 'CSUM')
        break
    end
end
meritFunction = 'No merit function';
nextZmxCommand = zmxSurfCommand;
end

%%%%%%%%%%%%%%%%%%%%%%%
function [multiConfigData,nextZmxCommand] = readMultiConfigurationData(inputFile)
disp('Currently multi-configuration data can not be imported. So all are just ignored');
% Ignore all lines of text, until we see one that just consists of
% this:{'MFDS', 'TOL','CSUM'}
while 1
    currentLine = readNextLine(inputFile);
    % read the line as space separated string
    currentLineArray = strread(currentLine,'%s');
    % The first element of the array is the 4 character zmx command
    zmxSurfCommand = char(currentLineArray(1,:));

    % Break if we hit end of file, or the start marker
    if ~ischar(currentLine)  ||  strcmp(zmxSurfCommand, 'MFDS')...
        ||  strcmp(zmxSurfCommand, 'TOL') ||strcmp(zmxSurfCommand, 'CSUM')...
        ||strcmp(zmxSurfCommand, 'EOF')
        break
    end
end
    multiConfigData = 'No multi configuration data';
    nextZmxCommand = zmxSurfCommand;
end

%%%%%%%%%%%%%%%%%%%%%%%
function [toleranceData,nextZmxCommand] = readToleranceData(inputFile)
disp('Currently tolerance data can not be imported. So all are just ignored');
% Ignore all lines of text, until we see one that just consists of
% this:{'MFDS', 'MNUM','CSUM'}
while 1
    currentLine = readNextLine(inputFile);
    % read the line as space separated string
    currentLineArray = strread(currentLine,'%s');
    % The first element of the array is the 4 character zmx command
    zmxSurfCommand = char(currentLineArray(1,:));

    % Break if we hit end of file, or the start marker
    if ~ischar(currentLine)  ||  strcmp(zmxSurfCommand, 'MFDS')...
        ||  strcmp(zmxSurfCommand, 'MNUM') ||strcmp(zmxSurfCommand, 'CSUM') 
        break
    end
end
    toleranceData = 'No Tolerance Data';
    nextZmxCommand = zmxSurfCommand;
end

%%%%%%%%%%%%%%%%%%%%%%%
function [surfaceArray,nextZmxCommand] = readSurfaceArray(inputFile)
    surfaceCounter = 1;
    surfaceArray = struct...
       ('Type',{},'Comment',{},'Radius',{},...
       'Thickness',{},'GlassName',{},'GlassType',{},'GlassParameters',{},...
       'SemiDiameter',{},'ConicConstant',{},'Parameters',{},...
       'CoatingName',{},'ApertureType',{},'ApertureParameter',{},...
       'ApertureDecenter',{},'UserDefinedApertureData',{},...
       'MirrorSubstrateShape',{},'MirrorSubstrateThickness',{},...
       'Stop',{},'ExtraData',{});
    % surfaceArray(surfaceCounter) = emptySurfaceStruct;

    
    currentLine = readNextLine(inputFile);
    % read the line as space separated string
    currentLineArray = strread(currentLine,'%s');
    % The first element of the array is the 4 character zmx command
    zmxSurfCommand = char(currentLineArray(1,:));
    validSurfaceCommand = 1;
    
    while validSurfaceCommand
        switch zmxSurfCommand           
            case 'HIDE'
            % HIDE hideRays noEdgesDraw noSurfDraw rowColor noHyperHemisph 
            % surfIgnore edgeDrawType skipRays drawLocalAx ??0	
            % Setting to show/hide surface comps.
            % hideRays: is 1 if “Hide Rays To This Surface” is selected otherwise is 0.
            % noEdgesDraw: is 1 if “Don’t Draw Edges From This Surface” is selected otherwise is 0.
            % noSurfDraw: is 1 if “Don’t Draw This Surface” is selected otherwise is 0.
            % rowColor: 0(Default),1(Color 1),…,24(color 24),25(no color).
            % noHyperHemisph: is 1 if “Surface Can’t Be Hyperhemispheric” is selected otherwise is 0.
            % surfIgnore: is 1 if “Ignore This Surface” is selected otherwise is 0.
            % edgeDrawType: 0(Squared to Next Surface),1(Tapered To Next Surface),2(Flat To Next Surface)
            % skipRays: is 1 if “Skip Rays To This Surface” is selected otherwise is 0.
            % drawLocalAx: is 1 if “Draw Local Axis” is selected otherwise is 0.
            %  ??0
            disp(['Surf ',num2str(surfaceCounter),...
                ' Warning: Hide setting (HIDE) is just ignored for now.']);
            case 'POPS'
            % POPS autoResample useRays don'tRescaleBeamSize UseAngSpectProp OutputPilotRad DrawBeamFile Resample XSamp 1=32,2=64,...) YSamp XWidth  YWidth ??0 XRad YRad useXAxisRef	Physical optics propagation data
            % autoResample: is 1 if “Auto Resample” is selected and 0 otherwise.
            % useRays: is 1 if “Use Rays To Propagate To Next Surface” is selected and 0 otherwise.
            % don'tRescaleBeamSize: is 1 if “Don not Rescale Beam Size Using Ray Data” is selected and 0 otherwise.
            % UseAngSpectProp: is 1 if “Use Angular Spectrum Propagator” is selected and 0 otherwise.
            % OutputPilotRad: 0:Best fit 1:shorter 2:longer 3:X 4:Y 5:Plane 6:User
            % DrawBeamFile: is 1 if “Draw Beamfile On Shaded Model” is selected and 0 otherwise.
            % Resample: is 1 if “Resample After Refraction” is selected and 0 otherwise.
            % XSamp: X-Sampling 1=32,2=64,...10=16384 
            % YSamp: Y-Sampling 1=32,2=64,...10=16384 
            % XWidth: X-Width
            % YWidth: Y-Width 
            % ??0 
            % XRad: X-Radius
            % YRad: Y-Radius
            % useXAxisRef: is 1 if “Use X-Axis Reference” is selected and 0 otherwise.
                disp(['Surf ',num2str(surfaceCounter),...
                    ' Warning: Physical Optics Propagation (POPS) is just ignored for now..']);                
            case 'MIRR'  
            % MIRR substShape substThick	The mirror substrate.
            % substShape: 0(None),1(Flat),2(Curved)
            % substThick: substrate thickness
            substShape = str2num(char(currentLineArray(2,:)));
            substThick = str2num(char(currentLineArray(3,:)));
            if substShape == 0
                surfaceArray(surfaceCounter).MirrorSubstrateShape = 'None';
            elseif substShape == 1
                surfaceArray(surfaceCounter).MirrorSubstrateShape = 'Flat';
            else 
                surfaceArray(surfaceCounter).MirrorSubstrateShape = 'Curved';
            end                            
            surfaceArray(surfaceCounter).MirrorSubstrateThickness = substThick;
            
            case 'CLAP' 
            % CLAP min max surfPickup	:Circular Aperture min and max radius. Index of Pickup surface otherwise 0.
                min = str2num(char(currentLineArray(2,:)));
                max = str2num(char(currentLineArray(3,:)));
                surfPickup = str2num(char(currentLineArray(4,:)));
                
                surfaceArray(surfaceCounter).ApertureType = 'Circular';
                aperParam(1) = min;
                aperParam(2) = max;
                surfaceArray(surfaceCounter).ApertureParameter = aperParam;
            case 'ELAP' 
            % ELAP xHalfWid yHalfWid surfPickup	: Elliptical aperture x and y half width. Index of Pickup surface otherwise 0.
                xHalfWid = str2num(char(currentLineArray(2,:)));
                yHalfWid = str2num(char(currentLineArray(3,:)));
                surfPickup = str2num(char(currentLineArray(4,:)));
                
                surfaceArray(surfaceCounter).ApertureType = 'Elliptical';
                aperParam(1) = xHalfWid;
                aperParam(2) = yHalfWid;
                surfaceArray(surfaceCounter).ApertureParameter = aperParam;
                
            case 'ELOB' 
            % ELOB xHalfWid yHalfWid surfPickup	: Elliptical Obscuration x and y half width. Index of Pickup surface otherwise 0.
                xHalfWid = str2num(char(currentLineArray(2,:)));
                yHalfWid = str2num(char(currentLineArray(3,:)));
                surfPickup = str2num(char(currentLineArray(4,:)));
                
                surfaceArray(surfaceCounter).ApertureType = 'EllipticalObscuration';
                aperParam(1) = xHalfWid;
                aperParam(2) = yHalfWid;
                surfaceArray(surfaceCounter).ApertureParameter = aperParam;                
            case 'FLAP'
            % FLAP 0 semiDiam surfPickup	: Floating Aperture
            % semiDiam: Semi-diameter 
            % surfPickup: Index of Pickup surface otherwise 0.
                semiDiam = str2num(char(currentLineArray(3,:)));
                surfPickup = str2num(char(currentLineArray(4,:)));
                
                % Use the max value as radius
                surfaceArray(surfaceCounter).ApertureType = 'Floating';
                aperParam(1) = semiDiam;
                aperParam(2) = semiDiam;
                surfaceArray(surfaceCounter).ApertureParameter = aperParam;                   
            case 'OBDC' 
            % OBDC xdec ydec	Aperture and Obscuration decenter in x and y direction.
                xdec = str2num(char(currentLineArray(2,:)));
                ydec = str2num(char(currentLineArray(3,:)));                
                aperDecenter(1) = xdec;
                aperDecenter(2) = ydec;
                surfaceArray(surfaceCounter).ApertureDecenter = aperDecenter;            
            case 'OBSC' 
            % OBSC min max surfPickup	Circular Obscuration min and max radius. Index of Pickup surface otherwise 0.
                min = str2num(char(currentLineArray(2,:)));
                max = str2num(char(currentLineArray(3,:)));
                surfPickup = str2num(char(currentLineArray(4,:)));
                
                surfaceArray(surfaceCounter).ApertureType = 'CircularObscuration';
                aperParam(1) = min;
                aperParam(2) = max;
                surfaceArray(surfaceCounter).ApertureParameter = aperParam;
            case 'SPID' 
            % SPID widArms numbArms surfPickup	Spider width of Arm and number of arms. Index of Pickup surface otherwise 0.
                widArms = str2num(char(currentLineArray(2,:)));
                numbArms = str2num(char(currentLineArray(3,:)));
                surfPickup = str2num(char(currentLineArray(4,:)));
                
                surfaceArray(surfaceCounter).ApertureType = 'Spider';
                aperParam(1) = min;
                aperParam(2) = max;
                surfaceArray(surfaceCounter).ApertureParameter = aperParam;                
            case 'SQAP' 
            % SQAP xHalfWid yHalfWid surfPickup	Rectangular aperture x and y half width. Index of Pickup surface otherwise 0.
                xHalfWid = str2num(char(currentLineArray(2,:)));
                yHalfWid = str2num(char(currentLineArray(3,:)));
                surfPickup = str2num(char(currentLineArray(4,:)));
                
                surfaceArray(surfaceCounter).ApertureType = 'Rectangular';                                       
                aperParam(1) = xHalfWid;
                aperParam(2) = yHalfWid;
                surfaceArray(surfaceCounter).ApertureParameter = aperParam;                      
            case 'SQOB' 
            % SQOB xHalfWid yHalfWid surfPickup	Rectangular Obscuration x and y half width. Index of Pickup surface otherwise 0.
                xHalfWid = str2num(char(currentLineArray(2,:)));
                yHalfWid = str2num(char(currentLineArray(3,:)));
                surfPickup = str2num(char(currentLineArray(4,:)));
                
                surfaceArray(surfaceCounter).ApertureType = 'RectangularObscuration';                                       
                aperParam(1) = xHalfWid;
                aperParam(2) = yHalfWid;
                surfaceArray(surfaceCounter).ApertureParameter = aperParam;                  
            case 'UDAD' 
            % UDAD I x y z	User defined aperture data. The first line is 
            % always <UDAD 0 “name.uda” UDAsclae>, then for I = 1,2,… 
            % the x and y data points corresponding to the user defined 
            % aperture are presented.
                I = str2num(char(currentLineArray(2,:)));
                if I == 0
                    name = str2num(char(currentLineArray(3,:)));
                    scale = str2num(char(currentLineArray(4,:)));
                    UDAxy = [];
                else
                    x = str2num(char(currentLineArray(3,:)));
                    y = str2num(char(currentLineArray(4,:)));
                    UDADxy = [UDAxy;x,y];
                end                               
                                                      
                surfaceArray(surfaceCounter).UserDefinedApertureData = UDADxy;                  
            case 'USAP' 
            % USAP min max surfPickup	User aperture. Index of Pickup surface otherwise 0.
                surfaceArray(surfaceCounter).ApertureType = 'UserAperture'; 
                min = str2num(char(currentLineArray(2,:)));
                max = str2num(char(currentLineArray(3,:)));
                surfPickup = str2num(char(currentLineArray(4,:)));
                
                aperParam(1) = min;
                aperParam(2) = max;
                surfaceArray(surfaceCounter).ApertureParameter = aperParam;  
            case 'USOB' 
            % USOB min max surfPickup	User Obscuration.
                surfaceArray(surfaceCounter).ApertureType = 'UserObscuration';  
                min = str2num(char(currentLineArray(2,:)));
                max = str2num(char(currentLineArray(3,:)));
                surfPickup = str2num(char(currentLineArray(4,:)));
                
                aperParam(1) = min;
                aperParam(2) = max;
                surfaceArray(surfaceCounter).ApertureParameter = aperParam; 
            case 'COAT' 
            % COAT name :	The name of coating (if any)             
            surfaceArray(surfaceCounter).CoatingName = (char(currentLineArray(2,:)));
            case 'COMM' 
            % COMM comment	Comment on the surface.
                surfaceArray(surfaceCounter).Comment = (char(currentLineArray(2,:)));
            case 'CONI' 
            % CONI val	Conic constant of the surface.
                conic = str2num(char(currentLineArray(2,:)));
                surfaceArray(surfaceCounter).ConicConstant = conic;
            case 'VCON' 
            % VCON	Variable conic constant.
                disp(['Surf ',num2str(surfaceCounter),' Warning: Conic '...
                    'constant solve/pickup is just ignored for now.' ]);
            case 'PKUP' 
            % PKUP Surf scale Col	Conic Constant pickup. 
            % Surf: From Surface index
            % Scale: Scale factor
            % Col: Pickup Column. 0(current),1(radius),2(thickness),3(conic),4(semidiameter),5(
                disp(['Surf ',num2str(surfaceCounter),' Warning: Conic '...
                    'constant solve/pickup is just ignored for now.' ]);
            case 'CURV' 
            % CURV val solveType param1 param2 param3 param4	The surface curvature.
            % Val: value of the curvature
            % solveType = 0 (fixed), 1(variable),2,3,… indicating the solve types (see the solves chapter from Zemax manual)
            % param1…4 : Solve parameters
            % 
                curv = str2num(char(currentLineArray(2,:)));
                solve = str2num(char(currentLineArray(3,:)));
                surfaceArray(surfaceCounter).Radius = 1/curv;
                if solve
                   disp(['Surf ',num2str(surfaceCounter),' Warning: Surface '...
                    'curvature solve/pickup is just ignored for now.' ]); 
                end    
            case 'SCOL' 
            % SCOL colIndex transparency	Surface Color.
            % colIndex: 0(default), 1-24(d/t color index)
            % transparency: (100 - Surface Opacity%)/10
                disp(['Surf ',num2str(surfaceCounter),' Warning: Surface '...
                    'color is just ignored for now.' ]);
            case 'SLAB' 
            % SLAB val	Surface labels. 
            % Val: unique integer assigned to each surface to identify the surface as new surfaces are inserted or old ones deleted. This can be used to know where a surface has moved to in the list of surfaces.
                disp(['Surf ',num2str(surfaceCounter),' Warning: Surface '...
                    'label is just ignored for now.' ]);
            case 'STOP' 
            % STOP	Marks Stop Surface.
                surfaceArray(surfaceCounter).Stop = 1;
            case 'SURF' 
            % SURF index	Surface index starting from 0 @ object surface.
                surfaceCounter = surfaceCounter + 1;
                % surfaceArray(surfaceCounter) = emptySurfaceStruct;
                disp(' ');
                
            case 'TYPE' 
            % TYPE surfType: 	surfType = STANDARD,EVENASPH,ODDASPHE...
            zemaxSurfaceType = char(currentLineArray(2,:));
            surfaceArray(surfaceCounter).Type = zemaxSurfaceType;           
            case 'GLAS' 
            % GLAS name code psurf nd vd pd vnd vvd vpd io ao	Glass 
            % name: The name of the glass or "___BLANK" if glass name is not given or "MIRROR" if mirror.
            % code: The glass type used. 0(Fixed or Mirror),1(Model),2(Pickup),3(Substitute),4(Offset)
            % psurf: Pickup Surface index. Only used for pickup surfaces and 0 otherwise.
            % nd,vd and pd: The index, abbe number and partial disperssion for the glass (but used only for model glass).
            % vnd,vvd and vpd: Variablity status of nd,vd and pd.
            % io and ao: Offset values (index offset and abbe offset)                
                name = char(currentLineArray(2,:));
                code = str2num(char(currentLineArray(3,:)));
                psurf = str2num(char(currentLineArray(4,:)));
                nd = str2num(char(currentLineArray(5,:)));
                vd = str2num(char(currentLineArray(6,:)));
                pd = str2num(char(currentLineArray(7,:)));
                vnd = str2num(char(currentLineArray(8,:)));
                vvd = str2num(char(currentLineArray(9,:)));
                vpd = str2num(char(currentLineArray(10,:)));
                io = str2num(char(currentLineArray(11,:)));
                ao = str2num(char(currentLineArray(12,:)));
                
                surfaceArray(surfaceCounter).GlassName = name;
                if code == 0
                    if strcmpi(name,'MIRROR')
                        surfaceArray(surfaceCounter).GlassType = 'Mirror';
                    else
                        surfaceArray(surfaceCounter).GlassType = 'Fixed';
                    end
                elseif code == 1
                    surfaceArray(surfaceCounter).GlassType = 'Model';
                elseif code == 2
                    surfaceArray(surfaceCounter).GlassType = 'Pickup';
                elseif code == 3
                    surfaceArray(surfaceCounter).GlassType = 'Substitute';
                else
                    surfaceArray(surfaceCounter).GlassType = 'Offset';
                end
                
                surfaceArray(surfaceCounter).GlassParameters = [vnd,vd,pd,vnd,vvd,vpd,io,ao];                
            case 'DIAM' 
            % DIAM val solveType param1 param2 param3 param4	The surface semidiameter.
            % Val: value of the semidiameter
            % solveType = 0 (automatic), 1(fixed),2(pickup),3(maximum),4(zpl macro)… indicating the solve types (see the solves chapter from Zemax manual)
            % param1…4 : Solve parameters
            % 
            semidiam = str2num(char(currentLineArray(2,:)));
            solveType = str2num(char(currentLineArray(3,:)));
            
            surfaceArray(surfaceCounter).SemiDiameter = semidiam;
            if solveType
                disp(['Surf ',num2str(surfaceCounter),' Warning: Semidiameter '...
                    ' solve/pickup is just ignored for now.' ]);
            end            
            case 'SDMA' 
            % SDMA marigin% fastsmd marigin:	Fast semidiameter.
            % Marigin: Semi diameter margin meters
            % marigin%: Semi diameter margin % 
            % fastsmd : is 1 if “Fast Semi-Diameters” is selected otherwise it is 0.
                disp(['Surf ',num2str(surfaceCounter),' Warning: Surface margin '...
                    ' parameters is just ignored for now.' ]);
            case  'DISZ'
            % DISZ val: The Z thickness of the surface.
                thick = (char(currentLineArray(2,:)));
                if strcmpi(thick,'INFINITY')|| strcmpi(thick,'INF')
                    thick = Inf;
                else
                    thick = str2num(thick);
                end
                surfaceArray(surfaceCounter).Thickness = thick;
            case {'CHZH', 'EDGE','MAZH','OPDZ' ,'PZUP' ,...
                    'TCOC','TCOM' ,'TOLE','TPUP','VDSZ'} 
                disp(['Surf ',num2str(surfaceCounter),' Warning: Thickness '...
                    ' solve/pickup is just ignored for now.' ]);
            case 'SCBD' 
            % SCBD beforeAfter order pickupType decX decY tiltX tiltY tiltZ	SCBD => ??TILT AND DECENTER DATA
            % beforeAfter: 1(before surface) , 2(after surface)
            % order: 0(Decenter,Tilt), 1(Tilt,Decenter)
            % pickupType:0(Explicit), 1(Pick This Surf), 2(Reverse This Surf), 3(Pick This Surf-1), 4(Reverse This Surf-1),..., 2n+1(Pick Surf - n), 2n+2(Reverse Surf - n )
            % decX decY tiltX tiltY tiltZ
                disp(['Error: Tilt and decenter data for surface is not currently',...
                    ' supported. Please use Coordinate break surface instead.']);
            case 'PARM'
                % PARM n val	Parameter n is the value of "val".
                n = str2num(char(currentLineArray(2,:)));
                value = str2num(char(currentLineArray(3,:)));
                surfaceArray(surfaceCounter).Parameters(n) = value;
                
            case 'XDAT'
            % XDAT I value solveType fromSurf scale offset fromCol ""
            % Extra data associated with the surface
            % I: Extra data index starting from 1.
            % value: The value of extra data
            % solvetype: solveType = 0 (automatic), 1(fixed),2(pickup),3(maximum),4(zpl macro)… indicating the solve types (see the solves chapter from Zemax manual)
            % fromSurf: Surface index from which to pickup value
            % scale: Scale factor
            % offset: Offset
            % fromCol: From column

                disp(['Surf ',num2str(surfaceCounter),' Warning: Extra '...
                    ' data is not supported.' ]);
                I = str2num(char(currentLineArray(2,:)));
                value = str2num(char(currentLineArray(3,:)));
                surfaceArray(surfaceCounter).ExtraData(I) = value;
                
            otherwise
                validSurfaceCommand = 0;
        end
        currentLine = readNextLine(inputFile);
        % read the line as space separated string
        currentLineArray = strread(currentLine,'%s');
        % The first element of the array is the 4 character zmx command
        zmxSurfCommand = char(currentLineArray(1,:));
     end
     nextZmxCommand = zmxSurfCommand;
end